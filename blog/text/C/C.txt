
********************************************************************************************************C语言  修仙笔记*****************************************************************************************************************
*																																																									   *	
*																																												   													   *						
****************************************************************************************************************************************************************************************************************************************

此笔记从2018年8月份开始纪录！！

hello world———————————————————————————————————————————————————————————————————————————————————————————C语言程序的基本结构———————————————————————————————————————————————————————————————————————————————————————————————————————————————


#inclcde <stdio.h>								以#开头的语句称为预处理器指令			#include语句不是必须的，但是如果一旦程序中有该语句，就必须将它放在程序的开始处			inclcde包涵			stdio是standared input output(精准的 输入 输出)		h是header(头;.h 头文件，相当于文件的标题)			总体意思；预处理包涵标准的输入输出头文件
void main()										main()函数是C程序处理的起点/入口		main()函数可以返回一个值，也可以不返回值。如果某个函数没有返回值，那么在它面前就是关键字void
{
	printf("Hello word!\n");					 printf是打印  以某种格式打印			作用是在屏幕上打印一行文字；“Hello World!”		后面写/n是换行（相当于打了一个回车），后面写/t相当于Tab键(空4格)		最后的分号表示语句结束
}


—————————————————————————————————————————————————————————————————————————————————————————————————————————菜鸟小结——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————


1、所有的符号都要成对敲			例；	<>	() {}	""	''	/*  */
2、分号一定要是英文的分号		英文分号;（占一个字节）	中文分号；（占两个字节）


书写注释是一个良好的编程习惯，注释是给人看的，不执行，相当于笔记
1、有助于对代码的阅读
2、注释语言应准确、易懂、简洁
//       			 			单行注释（只注释一行）					
/*  */	 			 			多行注释（以/*开头，*/结尾）（/*和*/之间是注释内容）


编译和执行过程
1、编译				形成目标代码是编译器的输出结果，常见扩展名为“.o”或“.obj”
2、连接				将目标代码跟C函数库相连接，并将源程序所用的库代码与目标代码合并			形成最终可执行的二进制代码（可执行程序）
3、执行				在特定的机器环境下运行C应用程序

程序的基本概念；为了解决某个问题而编写的一系列有序指令的集合
算法就是将输入转为输出的一系列计算步骤（方法与步骤）
流程图是算法的一种图形化表示方式					圆角矩形表示开始和结束		平行四边形表示输入和输出		菱形表示判断
C程序编写完成后，首先需要通过编译转换成目标文件，然后通过连接创建可执行程序，最后才可以执行该程序


新手司机上路———————————————————————————————————————————————————————————————————————————————————————变量、数据类型及运算符—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
			
内存如何存放数据
	计算机执行程序时，组成程序的指令和程序所操作的数据必须存放在某个地方			
	这个地方就是计算机的内存			
	也称为主内存（main memory）或随机访问储存器（Random Access Memory,RAM）······q

变量
	变量是计算机中一块特定的内存空间			
	由一个或者多个连续的字节组成
		
		
定义一个变量		
			
	数据类型加变量名		
		例如；
		int a;	
		double b;	
		char c;
			
			
变量名不能重复		
			
			
一条语句可以声明多个变量		
	例如；
		int a,b,c,d,e,f,g;(可以节省代码行，看起来舒服，也更容易查找)
			
			
变量的命名

通过变量名可以简单快速地找到在内存中存储的数据
			
	C语言变量命名规则
			1、C语言规定变量名（标识符）只能由字母、数字和下划线3种字符组成，且第一个字符必须为字母或下划线
			2、变量名不能包含除_以外的任何特殊字符，如；%、#、逗号、空格等
			3、不可以使用保留字（关键字）（32个保留字）				

保留字（关键字）
			保留字又称关键字。
			指在高级语言中已经定义过的字，使用者不能再将这些字作为变量名或过程名使用。
			每种程序设计语言都规定了自己的一套保留字。
			C有 22+10 = 32个关键字
			C++ 有22+10+11+20 = 63 个关键字
			JAVA 有22+ 9+ 17 = 48 个关键字 
	
	类型说明保留字:
			int,long,short,float,double,char,unsigned,signed,const,void,volatile,enum,struct,union
	语句定义保留字:
			if,else,goto,switch,case,do,while,for,continue,break,return,default,typedef
	存储类说明保留字:
			auto,register,extern,static
	长度运算符保留字:
			sizeof
	
	具体含义；
			auto							指定变量的存储类型，是默认值
			break							跳出循环或switch语句
			case							定义switch中的case子句
			char							定义字符型变量或指针
			const							定义常量或参数
			continue						在循环语句中，回到循环体的开始处重新执行循环
			default							定义switch中的default子句
			do								定义do-while语句
			double							定义双精度浮点数变量
			else							定义枚举类型
			enum							声明外部变量或函数
			extern							声明外部变量或函数
			float 							定义浮点型变量或指针
			for								定义for语句
			goto							定义goto语句
			if								定义if语句或if-else语句
			int								定义整型变量或指针
			long							定义长整型变量或指针
			register						指定变量的存储类型是寄存器变量，Turbo c中用自动变量代替
			return							从函数返回
			short							定义短整型变量或指针
			signed							定义有符号的整型变量或指针
			sizeof							获取某种类型的变量或数据所占内存的大小，是运算符
			static							指定变量的存储类型是静态变量，或指定函数是静态函数
			struct							定义结构体类型
			switch							定义switch语句
			typedef							为数据类型定义别名
			union							定义无符号的整型或字符型变量或指针
			unsigned						定义无符号的整型变量或数据
			void							定义空类型变量或空类型指针，或指定函数没有返回值
			volatile						变量的值可能在程序的外部被改变
			while							定义while或do_while语句


数据类型
			
	C语言中的基本数据类型有整形、字符型、浮点型：单精度型、双精度型; 枚举类型、数组等。


				 |————基本类型
				 |
				 |
				 |				  |————数组
				 |				  |
				 |				  |————结构体struct
	C数据类型————|————结构类型————|
				 |				  |————共用体union
				 |				  |
				 |				  |————枚举类型enum
				 |
				 |
				 |————指针类型
				 |
				 |
				 |————空类型void




							|————————非数值char（字符类型）
							|
							|
							|					   
							|					   |————int（整形）
	数据类型（基本类型）————|					   |
							|		  |————整形————|————short（短整型）
							|		  |			   |
							|		  |			   |————long（长整型）
							|		  |
							|		  |
							|—————————|	
									  |
									  |			   |————float（单精度型）
									  |——非整形————|									
									   （浮点型）  |————double（双精度型）
	
		
使用整形变量（int、short、long）；										
			
	声明整型变量；		
		int a;	
		short b;	
		long c;	
			
	初始化变量
		a = 590;
		b = 20;
			
			
使用单精度浮点型变量（float）
		
	float类型变量赋值时需要在数值的末尾加上一个f
		
	float小档案；
		位数；32位
		空间；4个字节
		取值范围；10的负38次方 至 10的正38次方
		7位有效数字
		
	声明及初始化
		float a = 150.0;
		float b;
		b = 98.5f;
			
			
使用单精度浮点型变量（double）			
			
	double小档案；
		位数；64位
		空间；8个字节
		取值范围；10的负308次方 至 10的正308次方
		16位有效数字
			
	声明及初始化
		double a = 1547.2598745;
		double b;
		b = 98.5;
			
	通常小数被储存为double类型，如2.0和9.0
			
	数字后使用1.时，数字成为long double类型，如4.761
			
			
使用字符型变量（char）
			
	char小档案；
		位数；8位
		空间；1个字节
		取值范围；负123 至 正127
			
	//打印字符对应的ASCII码（ASCII码在下面）
		char ch1 = 'a'		//大写字母a
		char ch2 = 'A'		//大写字母a
		char ch3 = ' '		//空格
		printf("字符\tASCII码\n");
		printf("%c\t%d\n",ch1,ch1);
		printf("%c\t%d\n",ch2,ch2);
		printf("%c\t%d\n",ch3,ch3);
		printf("%c\t%d\n",ch1-32,ch1-32);，
			
	注意；
		1、有符号signed char,取值范围 负128 至 正127
		2、无符号unsigned char,取值范围 0 至 255
		3、char类型是否有符号取决于编译器
			
			
printf函数和转换字符
				
	转换字符	  |      	    输出					|						示例
				  |										|		
	%d or %i	  | 	  有符号十进制整数				|		printf("%d心%i意\n",3,2);
	   %u		  |			十进制无符号整数			|
	   %o  	  	  |		以八进制表示的整数				|
	   %x		  |		以十六进制表示的整数			 |
	   %e 		  |		指数形式的浮点数				 |	
	   %p  		  |				指针的值				| 	
	   %c		  | 		  单个字符					|		printf("少林功夫好（y/n)—%c\n",'y');
	   %s		  | 		   字符串				    |		printf("爱我的人%s，我爱的人%s\n",“呵呵呵”,"老美了");
	   %f		  |   浮点数，默认精确到6位小数			 |		printf("圆周率；%.2\n",3.1415926);
	   %lf 		  |			double型浮点数				|
	   %%		  |  	   打印一个百分号				|		printf("手游占中国网络游戏海外发行细分市场的65%%");


特殊应用：
			%3d 				%03d				%-3d 				%5.2f
	%3d：要求宽度为3位，如果不足3位，前面空格补齐；如果足够3位，此语句无效
	%03d：要求宽度为3位，如果不足3位，前面0补齐；如果足够3位，此语句无效
	%-3d：要求宽度为3位，如果不足3位，后面空格补齐；如果足够3位，此语句无效
	%.2d：小数点后只保留2位

						
占位符；						
			
	int、short				%d		
	long					%ld(long 是int得修饰，不能算是一种单独的数据类型，只是比int多了四个字节的存储空间)		
	long long				%lld		
	char					%c 
	float					%f（float默认是6位小数输出；可以在%f中控制；例如：%.2f：输出两位小数）		
	double					%lf		
			
			
常用ASCII码汇总表
			
	值			符号		|		值			符号		|		值			符号		|		值			符号
							|								|								|		
	0		  空字符\0		|		42			 *			|		62			  >			|		123			  {
	32			空格		|		43			 +			|		63			  ？		|		124			  |
	33			 ↑			|		44			 ,			|		64			  @			|		125			  }
	34			 "			|		45			 -			|	   65~90		 A~Z		|		126			  ~
	35			 #			|		46			 .			|		91			  [			|		127		 DBL{Delete键}
	36			 $			|		47			 /			|		92			  \			|		
	37			 %			|	   48~57		0~9			|		93			  ]			|
	38			 &			|		58			 ；			|		94			  ^			|
	39			 ‘			|		59			 ;			|		95			  —			|
	40			（			|		60			 <			|		96			  `			|
	41			 ）			|		61			 =			|	  97~122		 a~z		|
			
	一个空格的值是32		
		空格加32得出大写A	
			
	大写字母转小写字母		
		大写字母加32得出小写字母	
			
	小写字母转大写字母
		小写字母减32得出大写字母
			
			

转义序列小结
		
	转义序列小结		|			名称			|					描述
						|		  					|		
		\a				|		  蜂鸣警报			|		在一些系统中不起作用
		\b				|			退格			|		将光标回退一格
		\f				|			换页			|		将光标移到下一页的开始处
		\n				|			换行			|		将光标移到下一行的开始处
		\r				|			回车			|		将光标移到当前行的开始处
		\t				|		  水平制表			|		将光标移到下一个水平制表位置
		\v				|		  垂直制表			|		将光标移到下一个垂直制表位置

		\'				|		   单引号			|		用于打印单引号、双引号、问号、反斜线等字符
		\"				|		   双引号			|		（由于这些字符用于定义字符常量，是printf函
		\?				|			问号			|		数的一部分，若直接使用会造成混乱）
		\\				|		   反斜线			|
			
			
scanf函数
		
	概述
		C函数库包涵了多个输入函数，scanf是最通用的一个，可以读取不同格式的数据
		
	基本用法
		int num;
		printf("请输入数量；");	
		scanf("%d",&num);	
			
	注意；		
		1、格式字符串的用法与printf函数类似	
		2、	读取基本类型的值时，变量前要加&符号


register函数

	概述
		用register修饰的变量是寄存器变量，变量会尽量将其储存空间分配在寄存器中
	
	注意
		1.定义的变量不一定真的存放在寄存器中。
		2.cpu取数据的时候去寄存器拿数据比去内存中拿数据要快
		3.因为寄存器比较宝贵，所以不能定义寄存器数组
		4.register只能修饰字符型及整形的，不能修饰浮点型
			例：
				register char num;
				register int num;
				register short int num;
				register long int num;
				register float num;//错误的
				register double num;//错误的
		5.因为register修饰的变量可能存放在寄存器中不存放在内存中，所以不能对寄存器变量取地址，因为只有存放在内存中的数据才有地址
			例：
				register int a;
				int *p;
				p=&a;//错误的，a可能没有地址


static
	概述
		static是静态的意思，static可以修饰全局变、局部变量、函数。


const
	概述
		const是常量的意思，用const修饰的变量是只读的，也可以修饰指针，不能修改它的值
	基本用法
		const int a=101;//在定义a的时候用const修饰，并赋值为101，从此以后就不能再给a赋值了
		a=111;//错误的


auto int a;和int a;是等价的，auto关键字现在基本不用


extern 是外部的意思，一般用于函数和全局变量的声明


sizeof
	概述
		使用来测变量、数组的占用存储空间的大小（字节数）
	
	例： 
		int a=10;
		int num;
		num=sizeof(a);


typedef 重命名相关的关键字
	概述
		关键字，作用是给一个已有的类型，重新起个类型名，并没有创造一个新的类型

	例： 
		unsigned int uint;
		uint a;


volatile
	概述
		volatile是易改变的意思，用volatile定义的变量，是易改变的，即告诉cpu每次用volatile变量的时候，重新去内存中取
		保证用的是最新的值，而不是寄存器中的备份，volatile关键字现在很少适用
	
	例： 
		volatile int a=10;
			
						
取模
			
	符号是%	
			取模的意思是取余数	
						
	例如		
		5 % 2 = 2·········1
			
	取模的符号和第一位数一致，例如；		
		5 % 2				1	
		5 % -2				1		
		-5 % 2				-1		
		-5 % -2				-1		
			
小议类型转换			
			
	自动类型转换		
		原则；把表示范围小的类型的值转换到表示范围大的类型的值，以保证精度不降低	
		short -> int —> long —> float -> double
	
	转换方向:
		高		    (双精度浮点型)double		←---		float（单精度浮点型）
								  ↑
								  |
						（长整型）long
								  ↑
								  |
					(无符号整型)unsigned int
								  ↑
								  |
		低	（有符号整型，int）signed int		←---		char、short（字符型，短整型）
	
	强制转换
		通过类型转换运算来实现
		（类型说明符）（表达式）
		
		功能：
			把表达式的运算结果强制转换成类型说明符所表示的类型
			注意：
				类型说明符必须加括号
		
		例如:
			(float)a;//把a的值转换为实型
			(int)(x+y)//把x+y的结果值转换为整型
			
	注意：
		1.当表达式中同时出现了char、short  int、int类型中的一种或者多种，没有其他类型了，参加运算的成员全部变成int类型的参加运算，结果也是int型的	
			例：
				printf("%d\n",5/2);//最终结果为2，由此可得，整数除以整数结果也为整数，小数部分省略
		
		2.当表达式中出现了带有小数点的实数，参加运算的成员全部变成double类型的参加运算，结果也是double型的
			例：
				printf("%lf\n",5.0/2);//结果为2.500000，
			
		3.当表达式中有有符号数 也有无符号数，参加运算的成员变成无符号参加运算结果也是无符号数（表达式中无实数）

		4.在赋值语句中等号右边的类型自动会转换为等号左边的类型
			例： 
				int a;
				floa b=5.8f;//5.8后面加f代表5.8是float类型
				a=b;
				printf("a=%d\n",a);//最终打印的结果为5，小数点后面自动省略

		5.自动类型转换都是在运算的过程中进行临时性的转换，并不会影响自动类型转换的变量的值和其他类型
			例： 
				int a;
				floa b=5.8f;//5.8后面加f代表5.8是float类型
				a=b;
				printf("a=%d\n",a);//最终打印的结果为5，小数点后面自动省略
				printf("b=%f\n",b);//最终结果为5.8，所以并不会影响自动类型转换的变量的值和其他类型

			
			
初级驾照————————————————————————————————————————————————————————————————————————————————————————————————————运算符与分支结构————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————			
			
			
C语言中，0表示假，1（非零）表示真
			
			
算数运算符与表达式			
			
	运算符	
		分为赋值运算符、算数运算符、关系运算符、逻辑运算符
		用算术运算符将运算对象（也称操作数）连接起来的、符合C语法规则的式子，称为C算术表达式，运算对象包括常量、变量、函数等
		例如：
			a*b/c-1.5+'a'
			
	赋值运算符
		单等号 =
			计算顺序；从左往右		例如；int a = 20;		不念int型变量a等于20		应该这样念把20赋值给int型变量a
					
	算数运算符
		一元运算符；++、--					（--就是减一、++就是加一）					一元运算符只需要一个参加操作数
		二元运算符；+、-、*、/、%			（加、减、乘、除、取模）					二元运算需要两个参加操作数

		当++是后置的时候，相当于先无视++运行一遍公式，再单独运行一次++(如果在前面就是先算++再算表达式，后置++不会被公式运算，前置++会被运算)
			int num = 5;							相当于			int num = 5;
			int result = 10;										int result = 10;
			int i;													int i;
			i = result - num++;										i = result - num;
			printf("i=%d\n",i);										num++;
			printf("num=%d",num);									printf("i=%d\n",i);		
																	printf("num=%d",num);

		双目运算符：参加运算的操作数有两个
			例如：a+b

		单目运算符：参加运算的操作数只(有一个
			++自增运算符	给变量值+1
			--自减运算符
			例如：int a=10;a++;

		三目运算符：参加运算的操作数有3个
			()?():()//第一个括号里面是条件表达式，若表达式成立则运行第二个阔号里的表达式，若不成立则运行第三个阔号里的表达式

	复合运算符：
		+=    -=    *=    /=    %=
		a+=3    相当于a=a+3
		a*=6+8  相当于a=a*(6+8);
			
	关系运算符
		关系运算符可以比较大小、高低、长短
			>、<							（大于、小于）
			>=、<=							（大于等于、小于等于）
			==、！=							（恒等、不等）			（恒等的意思是等于，一个等号是赋值的意思，两个等号才是等于）

	逻辑运算符
		
		运算符		|		表达式			|							说明
					|						|
		&&并且		|	条件1 && 条件2		|				 两个条件同时为真时，结果为真					与
		 ||或		|	条件1 || 条件2		|				两个条件有一个为真时，结果为真					或
		  ！		|		！ 条件			|		   条件为真时，结果为假;条件为假时，结果为真			非

	表达式	
			
		符号与操作数的结合	
			
		a	=	(	b	+	3	）	+	(	b 	-	1	)
		|		|				|		|				|
		|		|				|		|				|
		|		|				|		|				|
		|		——————表达式—————		—————表达式—————|
		|												|	
		|												|
		|——————————————————表达式———————————————————————|

		  
位运算符（选学）
			
	运算符		|		作用		|						示例
				|					|
	&		    |	   按位与		|			   两个操作数同时为1结果为1
	  |			|	   按位或		|		  两个操作数只要有一个为1，结果就为1
	  ~			|	   按位非		|		 操作数为1，结果为0;操作数为0，结果为1
	  ^			|	  按位异或		|		 两个操作数相同，结果为0;不相同结果为1
	  <<		|		左移		|		高位溢出，低位补0，每左移一位就相当于这个数乘2
	  >>		|		右移		|		左侧空位补符号位，右移分为逻辑右移和算术右移
	  >>>		|	 无符号右移		|					  左侧空位补0

	左移
		
		m << 1    ==    m * 2
		m << n    ==    m * (2 * n)
		
	右移：
	
		逻辑右移：高位补0，低位溢出

		算数右移：
			1.有符号数右移
				低位溢出，高位补符号位
				例如：
					1010 1010    >>    3     ==      1111 0101		//负数算数右移动3位
					0101 0101    >>    4     ==      0000 1010		//正数右移3位

			2.无符号数右移
				低位溢出，高位补0
				例如：
					1010 1010    >>    3    ==    0001 0101
					0101 0101    >>    3    ==    0001 0101
			
			
sizeof运算符			
			
	使用sizeof运算符可以获得数据类型占用内存空间大小		
		基本用法；sizeof(type name)	
		结果以字节为单位	
			
			
运算符优先级
	
	大小		
			
		↓		()sizeof ++ --	
		↓		!
		↓		算数运算符
		↓		关系运算符
		↓		&&
		↓		||
		↓		赋值运算符
				
	记忆技巧
		单目运算符包括！ ~ ++ -- sizeof ,优先级别高
		优先级别最低的是赋值运算符
		可以通过（）控制表达式的运算顺序，（）优先级最高
		从右向左结合性的只有赋值运算符、三目运算符和单目运算符
		算数运算符 > 关系运算符 > 逻辑运算符
	
	结合性
		从左往右算 左结合性    2+3-4+5+3+9
		从右往左算 右结合性    a=b=c=d=10;
				
				
条件结构				
	先判断后执行
		if(判断)				判断条件，条件为真时执行代码2，若为假，判断下一个条件
		{
			//代码块1
		}
		else
		{
			//代码块2			若以上条件都不符合，则执行代码块2
		}
			
			
多重if结构				
	常用来进行区间判断
		if(条件1)						先判断是否符合条件1，若符合，执行代码块1,若不符合，则判断是否符合条件2
		{
			//代码块1
		}
		else if(条件2)					若符合条件2，执行代码块2，若不符合，则判断下一个条件
		{
			//代码块2
		}		
		else							若以上条件都不符合，则执行代码块3
		{
			//代码块3
		}
				
switch结构				
			
	switch开关		
	case情况、案例（在switch里讲的是情况）
	break终止、跳出整个switch结构
	default默认
	
	switch(表达式)	        表达式只能是字符型或整型的（short int   int   long int）
	{
	case 变量1；			常量等于1的时候执行语句1
		 语句1;
		 break;				终止、跳出整个switch结构
	case 变量2；			常量等于2的时候执行语句2
		 语句2;
		 break;				终止、跳出整个switch结构
	......
	default					当前面的情况都不满足的时候，默认执行它
		 语句;	
		 break;
	}			
			
	使用switch结构时的注意点
		switch后的表达式只能是整形或字符型
		case后常量表达式的值不能相同
		case后允许多条语句，不需要大括号
		如果不添加break语句，需要特别注意执行程序
		case和default子句的先后顺序可以自行变动
		default子句可以省略
			
			
switch和多重if对比
	相同点
		都是用来处理多分支条件的结构
	不同点
		switch；等值条件判断-条件是有限个的时候（杀鸡刀）
		多重if；判断某个连续区间时的情况（杀牛刀）
			
			
总结；
	表达式是操作数和运算符的集合
	赋值运算符执行顺序是从右到左，优先级最低
	sizof运算符用来得到某一数据类型占用的字节数
	关系表达式的计算结果为逻辑真（非0）和逻辑假（0）
	处理条件分支判断的常用结构有三种；
		if-else结构
		if-else if-结构
		switch结构
			
			
中级驾照————————————————————————————————————————————————————————————————————————————————初探循环————————————————————————————————————————————————————————————————————————————————————————————————			
			
			
while循环
			
	特点；先判断，再执行

	while当······的时候			相当于if的加强版
			
	基本语法
		while(循环条件)
		{
			循环操作语句
		}
	
	循环三要素；
		循环变量的初值
		循环变量的判断
		循环变量的更新
	
	循环例子代码；
		int i = 0;					（初值）设定一个int型i变量，把0赋值给i
		while(i < 10)				（条件、判断）当i小于10的时候执行这块代码
		{
			printf("第%d遍",i);		打印这句话
		}	
			
			也就是说，当whild检测到i小于10时，执行代码块里的代码，执行完毕后，while再检测i是否小于10，若i小于10，则再执行，再检测，若大于或等于10，就停止循环
			
	怎么停止while循环；		
		int i = 0;					（初值）设定一个int型i变量，把0赋值给i
		while（条件、判断）当i小于10的时候执行这块代码
		{
			printf("第%d遍",i);		打印这句话
			i++;					（更新）打印上一句话后，把i代入加1
		}		
			
			也就是说，当whild检测到i小于10时，执行代码块里的代码，当打印出那段话后，把i代入加1，此时1等于1，1小于10，再循环一遍，每次循环都加1，当i等于10时，停止循环
			
			通过控制i的值可以控制循环的次数
			
	累加		
		int num = 0;				累加和
		int i = 1;					控制累加的次数
		while(i <= 100)				控制加到一百时停止
		{
			num += i;				每次的累加的和
			i++;					控制累加的次数
		}
			
			
随机函数；			
			
	rand();
		使用方法；
			printf("随机数字；%d\n",rand());
		
		作用；随机产生一个固定的数字（取值范围；0~32767）

	时间函数（使用时间作为种子，产生不一样的随机数字）（需要配合rand()一起使用）
		srand();
			需要导入一个新的头文件#include <time.h>		这是一个时间头文件
		
		例如；
			srand(time(NULL));		time是时间函数		NULL是现在		当填NULL的时候，取当前时间
			
		使用方法；（注意！要添加时间头文件！）
			srand(time(NULL));
			printf("随机数字；%d\n",rand());
			
	控制随机数字的值		
		如果想要取1234的值，那么就是1234 % 10 =4
		可以用取模的方式来控制随机数字的值
		想要控制随机数字的值就可以用取模的方式
			例如；
				rand() % 11			就是把随机数控制在0~10之间
				rand() % 12			就是把随机数控制在0~11之间
				rand() % 13			就是把随机数控制在0~12之间
				rand() % 14			就是把随机数控制在0~13之间
				rand() % 15			就是把随机数控制在0~14之间
				rand() % 16			就是把随机数控制在0~15之间
					这种方法有劣势，就是只能控制上限不能控制下限
					
			控制下限的方法；
				rand() % 16	+ 5
					把需要模的数字加上下限就可以控制下限了
					然而有一点要注意了！加5的意思是上限和下限全部加5
					所以上面的代码是把随机数控制在5~20之间
				例如；
					rand() % 11	+ 5		就是把随机数控制在5~15之间
					rand() % 12	+ 5		就是把随机数控制在5~16之间
					rand() % 13	+ 5		就是把随机数控制在5~17之间
					rand() % 14	+ 5		就是把随机数控制在5~18之间
					rand() % 15	+ 5		就是把随机数控制在5~19之间
					rand() % 16	+ 5		就是把随机数控制在5~20之间
					
			
Sleep函数			
			
	作用；让程序执行的慢一点

	用法；
		Sleep();				括号里可以填数字，以毫秒计算				
					
	用Sleep函数时需要加一个windouws头文件				
		#include <windows.h>			
					
					
do while循环					
					
	基本语法；				
					
		do{
			循环操作
		}while(循环条件);			
					
	特点；先执行，再判断			
		先执行一遍循环操作			
		符合条件，循环继续执行			
		否则循环退出			
					
	例题；				
		分析下面			
			int a = 1,b = 10;		
			do{
				b -= a;							//b = b - a 	      b = 10 - 1        这时候b的值为9
				a++;							//a = a + 1			  a = 1 + 1			这时候a的值为2
		    }while(b-- < 0);					//循环条件			  如果b小于零，则继续循环	然后执行b--    最后b的值为8
		则执行循环语句后b的值为（ D ）			
					
			A. 9    B.-2    C.-1    D.8		
					
								
while和do while对比					
					
	while循环和do while循环的区别				
		执行顺序不同
			while是先判断，再执行
			do while是先执行，再判断
	初始情况不满足循环条件时				
		while循环一次都不会执行			
		do while循环不管任何情况都至少执行一次			
					
					
取各个位的数字					
					
	例如；				
		int num = 1234;			
		//将四位数的每一位都取出来			
		printf("个位；%d\n",num%10);			除以10，得出的余数就是个位，得到的就是4
		printf("十位；%d\n",num/10%10);			先除以10，得出123.4 再取模，得到的就是3
		printf("百位；%d\n",num/100%10);		先除以100，得出12.34 再取模，得到的就是2
		printf("千位；%d\n",num/1000%10);		先除以1000，得出1.234 再取模，得到的就是1
		//规律；除10再模10			
		
		
		
		
	用循环来计算
		int num =123456789
		int temp;								//临时变量			
		while(num > 0)							//当num大于0时开始循环	
		{
			printf("%d\n",num%10);				
			num/=10;							//取出个位数字后，立即去掉个位数字
		}
					
	两段代码实现的功能是相同的，用循环会更方便一些，实际上这个程序实现了数字的反转，原本是1234，变成了4321				
					
					
总结；					
	循环结构可以理解为加强版的if				
	循环三要素在初期是理解循环原理的拐杖				
	while循环先判断后执行				
	do while循环先执行后判断				
	注意死循环（永远都不会结束的循环）				
	exit(0);									//退出系统（正常退出）				非零是非正常退出（闪退、其他因数导致程序退出）				
					
					
高级驾照————————————————————————————————————————————————————————————————————————————————————————————for循环——————————————————————————————————————————————————————————————————————————————————————————————————————————					
					
					
for循环					
	语法；				
		for(表达式1;表达式2;表达式3)			
		{			
			语句;
		}			
		表达式1,通常是为循环变量附初值，可省略，例如；i=0或cnt=20或coun=1			
		表达式2,循环条件，是否继续执行循环，可省略，例如；i<10或cnt==20或coun>=5
		表达式3,更新循环变量的值，可省略，例如；i++或cnt+=2或coun-
		分号，用来分隔三个表达式，不可省略！for(;)是死循环	
	代码；				
		int i;									//表达式i,通常是为循环变量
		for(i = 0;i < 9;i++)			
		{
			printf();							
		}								
	小结；				
		for循环常见问题；
			忘记定义循环变量或初始化
			循环条件缺少时会造成死循环
			循环变量不更新也会造成死循环
			不可省略分号
					
					
break语句					
	break语句的作用；				
		跳出循环，执行循环之后的语句			
	例如；				
		while(循环条件){						do{											for(;循环条件;){
			......									......										.....
			......									......										......
			break;——————————|跳						break;——————————————|跳						break;——————————————|跳
			......			|出						......			 	|出						......				|出
			......			|整						......				|整						......				|整
		}					|个					}while(循环条件);		|个					}						|个
							|循											|循											|循
		|———————————————————|环				   |————————————————————————|环				   |————————————————————————|环
		|									   |										   |
		↓									   ↓										   ↓
																									for循环很特殊，跳出后，循环变量不再更新
					
fflush(stdin);                  清空缓冲区，避免错误					
					
					
continue语句
	continue语句的作用；
		跳过本次循环，继续下次循环
	例如；				
		
				|———————————|				do{																|———————————————|
				|			|					......														|				|
				↓			|					......														|				|
							|					continue;———————————|										↓				|
		while(循环条件){	|					......				|					for(;循环条件;更新循环变量){		|
			......			|					......				|						......							|
			......			|				}while(循环条件);		|						......							|
			continue;———————|							↑			|						continue;———————————————————————|
			......										|			|						......
			......										|			|						......
		}												|———————————|					}
																									for循环很特殊，跳出本次循环后，循环变量依旧更新
					
					
break和continue对比					
	使用场合；				
		break可用于循环结构中			
		continue只能用于循环结构中			
	作用；				
		break语句终止某个循环，程序跳转到循环块外的下一条语句			
		continue跳出本次循环，进入下一次循环			
					
					
嵌套循环之打印星号图形					
	打印星号图形有两个关键；				
		1、行数 - 一共有几行			
		2、列数 - 每行有几颗星			
	外层循环    控制行（行数、换行）				
	内层循环	控制列（列数、列的符号）


goto
	跳转到指定的语句开始执行

	语句：
		goto 标签名;
	
	标签：
		标签名:.

	注意：
		尽量少使用，使用goto时只会在本函数中查找该标签				
					
					
老司机登场————————————————————————————————————————————————————————————————————————————数组及常用算法————————————————————————————————————————————————————————————————————————————————————————————————————————————							

					
什么是数组					
	数组是一个变量，由数据类型相同的一组元素组成				
		变量，相当于一个内存空间，数组实际上也是一个变量，所以也是一个内存空间			
					
	变量；内存中的一块空间				
	数组；内存中的一串连续的空间				
		只要数据类型相同，都可以称为数组			
		可以把数组看做变量的加强			
					
数组的结构和基本要素					
	标识符；数组的名称，用于区分不同数组				
	数组元素；向数组中存放的数据
	元素下标；对数组元素进行编号
	元素类型；数组元素的数据类型				
						
		标识符；数组的名称					例如；同学，这是一个统称	老师，这也是一个统称 	电脑，也是一个统称			
		数组元素；每个同学、老师、电脑				
		元素下标；从0开始					就是数组中每个元素的编号，一般从零开始		
		元素类型；数组的类型都是相同的		例如；要么都是学生，要么都是老师
					
					
	数组只有一个名称，即标识符（用来表示数组的变量名）				
	元素下标标明了元素在数组中的位置，从0开始				
	数组中的每个元素都可以通过下标来访问				
	数组长度固定不变，避免数组越界				
					
		例如；			
			3.14		0
			3.15		1
			3.16		2
			3.17		3
			3.18		4
					
				可以看出，这个数组类型是double	
				给它起个名叫nums	
				数组下标从0开始，长度是固定不变的，专业术语；数组的下标越界			
				在这个数组中，下标是从0到4的	假设访问5号元素，那肯定是没有的，错误的	
					
	使用数组的好处；				
		不用定义那么多的变量			
		更加方便的操作内存			
					
	注意；				
		数组中的所有元素必须属于相同的数据类型			
					
					
一维数组					
					
	例如；				
		学生单门学科的成绩			
		某类别商品单价			
		某人N个月的工资			
					
	语法:
	datatype arrayName[size]				左边是数据类型		右边是数组名		一个中括号，以及数组的大小				
					
	例如；				
		int	nums[25];							定义了一个25个元素的数组，Int型（整形）		名称是nums
		char array_of_name[30];			
		double curr_salary[35]			
					
					
		#define N 50					#define 的意思是宏定义 		也就是说；通过宏定义的方式定义了一个常量 	也就是N以后代表50了，是不能更改的	
		int emp_id[N];					在定义int emp_id时N就代表了一个常量的方式代表着数组的大小
		......			
		const int SIZE = 100;			const是常量 定义的时候就已经有数据类型了
		double prices[SIZE];			
					
			先定义define，定义的时候是没有类型的，只有在用的时候，编译器才给它转换成相应的类型		
					
	初始化一维数组				
		数组在定义以后，可以先给它初始化，初始化就是初值，也就是第一次给它定义值			
					
		例如；			
			int years[6]={2012,2013,2014,2015,2016,2017};		定义6个整数型（int型）元素的数组，名称为years,后边是6个元素		
					
			int months[12]={1,3,5,7,8,10,12};					定义12个整数型（int型）元素的数组，名称为months,这个也是正确的，后面5个元素未初始化，默认值为0		
					
			int days[]={1,15};									这个也正确，元素个数为两个		
					
			int array[]={};										这个会报错，未知元素个数！		
					
					
一维数组的动态赋值		
			
	动态的从键盘录入信息并赋值			
					
	使用数组的步骤；				
		1、要定义的数组是什么类型的			
		2、规定数组的大小			
		3、考虑如何给这个数组每一个元素赋值			
		4、给初值，还是常量值，还是动态赋值			
					
					
数组排序：					
					
	使用冒泡排序：				
					
		16  25  9  90  23			
			假设有这个5个数字		
			要求它降序排列（从大到小）		
					
		冒泡排序的基本原理是查找（遍历）和交换			
					
			第一轮循环：			
				某个数字小于后面的数字，那么就交换	
					结果；25  16  9  90  23
			第二轮循环：		
				某个数字小于后面的数字，那么就交换	
					结果；25  16  9  90  23
			第三轮循环：		
				某个数字小于后面的数字，那么就交换	
					结果；25  16  90  9  23		
			第四轮循环：		
				某个数字小于后面的数字，那么就交换	
					结果；25  16  90  23  9		
					
					到最后一轮的时候就发现了最小的数字（9）已经冒到了最后面
					
		特点：				
			1、需要比较多轮			（数组长度 - 1）轮		
			2、每一轮比较的次数比上一轮-1次		
			（数组长度 - 1）- 当前轮数			
					
					
		方法；利用循环和判断		
			
		代码：			
			int i,j;                                            //循环变量
			int temp;                                           //用来交换的临时变量
			int nums[N] = {16, 25, 9, 90, 23};
																//外层循环控制轮数
			for(i = 0; i < N - 1; i++)
			{
																//内层循环控制 每轮的比较次数
				for(j = 0; j < N - i - 1; j++)
				{
																//如果当前值小于后面一个值，就交换
					if(nums[j] < nums[j + 1])
					{
						temp = nums[j];
						nums[j] = nums[j + 1];
						nums[j + 1] = temp;
					}
				}
			}
			printf("排序后的结果是：\n");
			for(i = 0; i < N; i++)
			{
				printf("%d\t",nums[i]);
			}		
					
		在数组已经有序的情况下				
		逆序可以重复采用冒泡排序的方式			
					
		如果数组初识无序的情况下，要求数组逆序输出			
		12  34  23  67  9			
		i 				N - i - 1								若i == 0，那么i表示的是第0个元素，N - i - 1表示的是第4个元素		
			i		N - i - 1									若i == 1, 那么i表示的是第1个元素，N - i - 1表示的是第3个元素
		逆序：			
			第一个元素和最后一个元素交换		
			第二个元素和倒数第二个元素交换		
			逆序的代码：
				for(i = 0; i < N; i++);		
				{
				temp = nums[i];
				nums[i] = nums{N - i - 1};
				nums[N - i - 1] = temp;
				}		
					
					
数组元素的删除和插入					
					
	删除步骤：				
		1、查找要删除数字的下标			
		2、从下标开始，后面一个覆盖前面一个数字			
		3、数组的总长度-1			
					
	插入步骤：				
		1、定义一个无效的函数			
		2、增加数组的元素			
		3、把输入的值赋值进去


按元素的类型分类
	1.字符数组
		即若干个字符变量的集合，数组中的每个元素都是字符型的变量
		char s[10];    s[0],s[1]...s[9];
	2.短整型的数组
		short a[10];   a[0],a[9];a[0]=4;a[9]=8;
	3.整型的数组
		int a[10];     a[0],a[9];a[0]=3;a[0]=6;
	4.长整型的数组
		long int a[5];
	5.浮点型的数组（单、双）
		float a[6];a[4]=3.14f;
		double a[8];a[7]=3.115926;
	6.指针数组
		char *a[10];		//字符指针数组
		int *a[10];			//整型指针数组
	7.结构体数组
		struct stu boy[10];


按维数分类
	一维数组
		int a[10];
		可以理解为一排平房

	二维数组
		int a[2][30];
		可以看作一栋楼房 第一个中括号的常量代表着多少层，第二个括号中的常量代表着多少个房间，也类似
		于数学中的矩阵，二维数组可以看成由多个一维数组构成的，有行有列

	多维数组
		int a[4][2][10];
		可以看作一个小区，第一个括号代表有几栋楼房，第二个中括号的常量代表着多少层，第三个括号中的
		常量代表着多少个房间，三维数组是由多个相同的二维数组构成的
		int a[5][4][2][10];
					
					
秋名山老司机——————————————————————————————————————————————————————————————————————————————二维数组——————————————————————————————————————————————————————————————————————————————————————————					
					
二维数组能表示：				
	学生多门学科的成绩			
	玩家的背包数据			
	游戏角色行走动画			
					
语法：					
	datatype name[rowSize][colSize];				
	double score[5][3];				
	int animate[4][4];				
					
					
播放声音的关键代码：				
	#include <windows.h>			
	#include <mmsystem.h>			
	#pragma comment(lib,"Winmm.lib")			
				
	//播放音乐			
	PlaySound(TEXT("sounds\\背景音乐.wav"),										把路径改一下就能用了
		NULL,SND_FILENAME / SND_ASYNC / SND_LOOP);		
					
					
乘载灵魂之路——————————————————————————————————————————————————————————————————————————指针————————————————————————————————————————————————————————————————————————————————————————————————————————					
					
关于内存
	存储器：存储数据器件
	
	外存：
		外存又叫外部储存器，长期存放数据，掉电不丢失数据，常见的外存设备：
			硬盘、flash、rom、u盘、光盘、磁带

	内存：
		内存又叫内部储存器，暂时存放数据，掉电数据丢失，常见的内存设备：
			ram、ddr

		物理内存：实实在在存在的储存设备

		虚拟内存：操作系统虚拟出来的内存


指针（pointer)简介：					
	指针是一个值为内存地址的变量（或数据对象）									指针就是一个变量			
		内存地址一般使用16进制表示		
		指针不可以赋常量
					
	示例：				
			int year;		  指向		   int * ptr_year;
			  2016		←——————————————————	  0028FF44					
			0028FF44		
					
		int year被16赋值				int * ptr_year把year的内存地址取出来			
					
		代码：			
			int year;							int * ptr_year;	
			year = 2016;						ptr_year = &year;
												把year的地址取出来后，ptr_year的值为2016
					
	基本用法：				
		数据类型 * 指针变量名;			
	例如：
		int * ptr_num;				
		char * ptr_name;			
		float * money_ptr;			
		double * p_price;			
					
			ptr是pointer的缩写		
					
		注意：			
			在头文件<stdio.h>中，NULL被定义为常量		
			int * ptr_num = NULL;		
			指针的初值设为空，表示指针不指向任何地址		
			最好加上这段代码，如果不加入，它可能指向其他地址（不仅本身程序，还可能指向别的程序）
		
占位符：					
	%p指针占位符   %x 16进制占位符

指针的运算符：
	&取地址				*取值		
					
取地址符&				
			
			num					ptr_num		
			1024←———————————————0028FF44		
					
		代码：			
			int num = 1024;		
			int * ptr_num;		
			ptr_num = &num;				取num变量的地址赋值给ptr_num							&取地址			
					
间接运算符					
					
		num					ptr_num		
		1024←———————————————0028FF44			
	  0028FF44				
					
		int num = 1024;										定义一个int型num变量		
		int * ptr_num;										定义一个指针
		ptr_num = &num;										找到num的地址
					
		*ptr_num = 1111;									当指针遇到*时，找到它的内存空间，把1111写进去			顺着地址修改num的值（顺着网线打死你）			
		
指针的地址：		
	int * ptr_num = &ptr_num;	
		因为指针也是变量，所以它也有属于自己的地址

多字节变量的地址
	多字节变量就是占多个存储单元，每个存储单元都有地址编号，

	C语言规定，存储单元编号最小的那个编号，是多字节变量的地址编号。
		
扩展：
	对应类型的指针，只能保存对应类型数据的地址，
	如果想让不同类型的指针相互赋值的时候，需要强制类型转换

注意：
	* + 指针 取值，取几个字节，由指针类型决定的指针为字符指针则取一个
	指针为整型指针4个字节，指针为double型指针则取8个字节。

	指针++ 指向下个对应类型的数据
		字符指针++，指向下个字符数据，指针存放的地址编号加1
		整型指针++，指向下个整数数据，指针存放的地址编号加4
		
指针小结：					
	指针同样是一个变量，只不过该变量中存储的是另一个对象的内存地址				
	如果一个变量存储另一个对象的地址，则称该变量指向这个对象				
	指针变量可以赋值，指针的指向在程序执行中可以改变
		指针p在执行中某时刻指向变量x，在另一时刻也可以指向变量y
					
	注意：				
		1、指针变量的命名规则和其他变量的命名规则一样			
		2、指针不能与现有变量同名			
		3、指针可以存放c语言中的任何基本数据类型、数组和其他所有高级数据结构的地址			
		4、若指针已声明为指向某种类型数据的地址，则它不能用于储存其他类型数据的地址			
		5、应为指针指定一个地址后，才能在语句中使用指针	
		6.如果在一行中定义多个指针变量，每个指针变量前都需要加*号	
		7.无论什么类型的指针变量，在32位系统下，都是4个字节，只能存放对应类型	


指针和数组元素的关系
	1.变量存放在内存中，有地址编号，定义的数组是多个相同类型的变量的集合，每个变量都占内存空间，
		都有地址编号，指针变量可以存放数组元素的地址。
		例如：
			int a[10];
			//int *p=&a[0];
			int *p;
			p=&a[0];//指针变量p保存了数组a中第0个元素的地址，即a[0]的地址

	2.数组元素的引用方法
		方法1：数组名[下标]
			int a[10];
			a[2]=100;

		方法2：指针名加下标
			int a[10];
			int *p;
			p=a;
			p[2]=100;//因为p和a等价
			补充：
				c语言规定：数组的名字就是数组的首地址，即第0个元素的地址，是个常量。
			注意：
				p和a的不同，p是指针变量，而a是个常量。所以可以用等号给p赋值，但不能给a赋值
		
		方法3：通过指针运算加取值的方法来引用数组的元素
			int a[10];
			int *p;
			p=a;
			*(p+2)=100;//也是可以的，相当于a[2]=100;
			解释：
				p是第0个元素的地址，p+2是a[2]这个元素的地址。
				对第二个元素的地址取值，即a[2]


指针的运算
	1.指针可以加一个整数，往下指几个它指向的变量，结果还是个地址
		例1：
			int a[10];
			int *p;
			p=a;
			p+2;//p是a[0]的地址，p+2是&a[2]

		例2：
			double a[10];
			double *p;
			p=a;
			printf("%d\n",((int)(p+2))-((int)(p)));
			p+2是a[2]的地址，p是a[0]的地址，然后强制把地址转换为int型的十进制，
			double类型占8个字节，中间相差两个double类型的元素，2*8=16

	2.两个相同类型的指针可以比较大小
		前提：只有两个相同类型的指针指向同一个数组的元素的时候，比较大小才有意义
		指向前面元素的指针 小于 指向后面 元素的指针
			例：
				int main()
				{
					int a[10];
					int *p=NULL,*q=NULL;
					p=&a[0];
					q=&a[1];

					printf("p指向的地址为%p\tq指向的地址为%p\n",p,q);

					if(p<q)//比较地址的大小
						printf("p<q\n");
					else if(p>q)
						printf("p>q\n");
					else
						printf("p=q\n");

				return 0;
				}

	3.两个相同类型的指针可以做减法
		前提：必须是两个相同类型的指针指向同一个数组的元素的时候，做减法才有意义
		做减法的结果是两个指针指向的中间有多少个元素
		例：
			int main()
			{
				int *p=NULL,*q=NULL,a;
				p=&a;//把a的地址赋值给p，p指向了a的地址
				q=p;//用p给q赋值，q也保存了a的地址，指向a

				printf("a的地址为:%p\np指向的地址为:%p\nq指向的地址为:%p\n.",&a,p,q);

				return 0;
			}
		注意：
			如果类型不相同的指针要想相互赋值，必须进行强制类型转换
			c语言规定数组的名字，就是数组的首地址，就是数组第0个元素的地址
			int *p;
			int a[10];
			p=a;//p=&a[0];		//这两种赋值方法是等价的


指针数组

	1.指针和数组的关系

		1.指针可以保存数组元素的地址

		2.可以定义一个数组，数组中有若干个相同类型指针变量，这个数组被称为指针数组，
			指针数组本身是一个数组，是个指针数组，是若干个相同类型的指针变量构成的集合

	2.指针数组的定义方法

		类型说明符 * 数组名[元素个数];
			int *p[10];//定义了一个整型的指针数组p，有10个元素p[0]~p[9],每个元素都是int *类型的变量
			int a;
			p[1]=&a;
			int b[10];
			p[2]=&b[3];
			p[2]和 *(p+2)是等价的，都是指针数组中的第2个元素。

	3.指针数组分类
		字符指针数组char *p[10]、短整型指针数组、整型的指针数组、长整型的指针数组
		float型的指针数组、double型的指针数组
		结构体指针数组、函数指针数组


指针的指针
	指针的指针，也称为多级指针即指针的地址，定义一个指针变量本身指针变量占4个字节，指针变量也有地址编号
		int a;
		int *p; 
		p=&a;			//*p == a;
		int **q;
		q=&p;			//*q == p;		**q == *p == a;
		int ***m;
		m=&q;			//*(*(*m)) == a;


字符串和指针
	字符串的概念：
		字符串就是以“\0”结尾的若干的字符的集合

	字符串的存储形式：数组、字符串指针、堆
		1.char string[100] = "I Love C!"
		  定义了一个字符数组string,用来存放多个字符，并且用“I Love C!”给string数组初始化,
		  字符串“I Love C!”存放在string中

		2.char *str = "I Love C"
		  定义了一个指针变量str，只能存放字符地址编号，
		  所以说I Love C! 这个字符串中的字符不能存放在str指针变量中。
		  str只是存放了字符I的地址编号“I Love C!”存放在文字常量区

		3.char *str =(char *)malloc(10*sizeof(char));//动态申请了10个字节的存储空间，首地址给str赋值。
		  strcpy(str,"I Love C");//将字符串“I Love C!”拷贝到str指向的内存里


		字符数组：
			在内存（栈、静态全局区）中开辟了一段空间存放字符串

		字符串指针：
			在文字常量区开辟了一段空间存放字符串，将字符串的首地址付给str

		堆：
			使用malloc函数在堆区申请空间，将字符拷贝到堆区

		可修改性：

			1.栈和全局区内存中的内容是可修改的
				char str[100]="I Love C!";
				str[0]='y';//正确可以修改

			2.文字常量区里的内容是不可修改的
				char *str="I Love C!";
				*str='y';//错误，I存放在文字常量区，不可修改

			3.堆区的内容是可以修改的
				char *str=(char*)malloc(10*sizeof(char));
				strcpy(str,"I Love C!");
				*str='y';//正确，因为堆区的内容是可以修改的

			注意：
				str指针指向的内存能不能修改要看str指在哪里。
				str指向文字常量区的时候，内存里的内容不可以修改
				str指向栈、堆、静态全局区的时候，内存的内容是可以修改

		初始化：
			字符数组、指针指向的字符串：定义是直接初始化
				char buf_aver[]="Hello World";
				char *buf_point="Hello World";
			堆中存放的字符串
			不能初始化、只能使用strcpy、scanf赋值
				char *buf heap;//定义一个名为buf_heap的char型指针
				buf_heap=(char *)malloc(15);//申请一个15字节的空间，并把申请到的空间首地址赋值给buf_heap
				strcpy(buf_heap,"Hello World");//将Hello World 拷贝到buf——heap指向的地址
				scanf("%s",buf_heap);//或者从键盘获取一个字符串，填充到buf_heap所指向的地址
			使用时赋值
				字符数组：使用strcpy或scanf
					buf_aver="Hello Rise";				//错误，因为字符数组的名字是个常量
					strcpy(buf_aver,"Hello Rise");		//正确
					scanf("%s",buf_aver);				//正确
					指向字符串的指针：
					buf_point="Hello Rise"				//正确,buf_point指向另一个字符串
					strcpy(buf_point,"Hellp Rise")		//错误，只读，不能复制字符串到buf_piont指向的内存里
					取决于buf_point指向哪里。


数组指针：
	1.二维数组：
		二维数组有行有列，二维数组可以看作有多个一维数组构成的，是一个一维数组的集合，
		可以认位二维数组的每一个元素是一个一维数组

		例：
			int a[3][5]'
			定义了一个3行5列的一个二维数组
			可以认为二维数组a由3个一维数组构成，每个元素是一个一维数组。
		回顾：
			数组的名字是数组的首地址，是第0个元素的地址，是一个常量，数组名字加1指向下个元素
			 
			二维数组a中，a+1指向下个元素，即下个一维数组，即下一行
		
		例如：
			void main(void)
			{
				int a[3][5];
				printf("a=%p\n",a);
			}
				printf("a+1=%p\n",a+1);

	2.数组指针的概念：
		本身是个指针，指向一个数组，加1跳一个数组，即指向下个数组。

	3.数组指针的定义方法：
		指向的数组的类型（*指针变量名）[指向的元素的元素个数]

		int(*p)[5];//定义了一个数组指针变量p，p指向的是整型的有5个元素的数组
			p+1  往下指5个类型，跳过一个有5个整型元素的数组
		
		注意：
			int (*p)[5];	//定义了一个整型的数组指针p,共有5个元素，每个元素占4个字节用于储存地址
			int *p[5];		//定义了一个整型的指针数组p,共有5个元素，每个元素都是int型变量
		
		例子：
			int main()
			{
				int a[3][5];                //定义了一个3行5列的一个二维数组
				int (*p)[5];                //定义一个数组指针变量p，p+1跳一个有5个元素的整型数组
				printf("a=%p\n",a);         //第0行的行地址
				printf("a+1=%p\n",a+1);     //第1行的行地址，a和a+1差20个字节
				p=a;
				printf("p=%p\n",p);
				printf("p+1=%p\n",p+1);     //p+1跳一个有5个整型元素的一维数组
				//相差20个字节，一个整型元素占4个字节，一行有5个元素，4*5=20

				return 0;
			}

	4.各种数组指针的定义：
		1.一维数组指针，加1后指向下个一维数组
			int(*p)[5];

			配合每行有5个int型元素的二维数组来用
			int b[4][5];
			int c[5][5];
			int d[6][5];
			int a[3][5];
			...
			p=a;
			p=b;
			p=c;
			p=d;

		2.二维数组指针，加1后指向下个二维数组
			int (*p)[4][5];

			配合三维数组来用，三维数组中由若干个4行5列二维数组构成

			int a[3][4][5];
			int b[4][4][5];
			int c[5][4][5];
			int d[6][4][5];
			这些三维数组，由个共同的特点，又是由若干个4行5列的二维数组构成的。
			p=a;
			p=b;
			p=c;
			p=d;

	5.三维数组指针，加1后指向下个三维数组
		int(*p)[4][5][6];
		p+1跳一个由4个5行6列的二维数组构成的三维数组；
		配合：
			int a[7][4][5][6];

	6.四维数组指针，加1后指向下个四维数组，以此类推。。。。

	7.注意：
		指针数组：是个数组，有若干个相同类型的指针构成的集合
			int *p[10];
			数组p有10个int*类型的指针变量构成，分别是p[0]~p[9]

		数组指针：本身是个指针，指向一个数组，加1跳一个数组
			int(*p)[10];
			p是个指针,p是个数组指针，p加1指向下个数组，跳10个整形。

		指针的指针：
			int **p;//p是指针的指针
			int *p;
			p=&q;

	8.数组名字取地址：变成数组指针
		一维数组名字取地址，变成一维数组指针，即加1跳一个一维数组
			int a[10];
			a+1		跳一个整型元素，是a[1]的地址
			a和a+1	相差一个元素，4个字节

			&a就变成了一个一维数组指针，是int(*p)[10]类型的。
			(&a)+1和&a相差一个数组即10个元素即40个字节。

			void main()
			{
				int a[10];
				printf("a=%p\n",a);
				printf("a+1=%p\n",a+1);

				printf("&a=%p\n",&a);
				printf("&a+1=%p\n",&a+1);
			}

			a是int*类型的指针，是a[0]的地址
			&a变成了数组指针，加1跳一个10个元素的整型一维数组
			在运行程序时，a和&a所代表的地址编号是一样的，即他们指向同一个存储单元，但是a和&a的指针类型不同。

	9.数组名字和指针变量的区别：
		int a[10];
		int *p;
		p=a;
	
		相同点：
			a是数组的名字，是a[0]的地址，p=a即p也保存了a[0]的地址，即a和p都指向a[0],所以在引用数组元素的时候，a和p等价
			a[2]、*(a+2)、p[2]、*(p+2)都是对数组a中a[2]元素的引用。
	
		不同点：
			1.a是常量、p是变量
				可以用=号给p赋值，但是不能用=号给a赋值
			
			2.对a取地址和对p取地址结果不同
				因为a是数组的名字，所以对a取地址结果为数组指针。
				p是个指针变量，所以对p取地址（&p）的结果为指针的地址。

	10.多维数组中指针的转换：
		在二维数组中，行地址取 * 不是取值的意识，而是指针降级的意思，由行地址(数组指针)变成这一行第0
		个元素的地址。取*前后还是指向同一个地方，但是指针的类型不一样了
			int main()
			{
				int a[3][5];
				printf("a=%p\n",a);
				printf("a+1=%p\n",a+1);

				printf("*a=%p\n",*a);               //*a变成了第0行第0列元素的地址
				printf("(*a)+1=%p\n",(*a)+1);       //结果为第0行第一列元素的地址

				return 0;
			}


指针和函数的关系

	1.指针作为函数的参数
		咱们可以给一个函数传一个 整型、字符型、浮点型的数据，也可以给函数传一个地址。
		例：
			int num;
			scanf("%d",&num);
		函数传参：
			1.传数值：
				void swap(int x,int y)//形参
				{
					int temp;
					temp=x;
					x=y;
					y=temp;
				}
				int main()
				{
					int a=10,b=20;
					swap(a,b);//实参
					printf("a=%d b=%d\n",a,b);//a=10  b=20

					return 0;
				}
				实参：调用函数时传的参数
				形参：定义被调函数时，函数名后边括号里的数据
				结论：给被调函数传数值，只能改变被调函数形参的值，不能改变主调函数实参的值

			2.传地址：
				void swap(int *pl,int *p2)
				{
					int temp;
					temp=*p1;
					*p1=*p2;//将p2指向的变量的值赋值给p1指向的变量赋值
					*p2=temp;
				}
				void main()
				{
					int a=10,b=20;
					swap(&a,&b);
					printf("a=%d b=%d\n",a,b);//结果为a=20  b=10

					return 0;
				}
				结论：调用函数的时候传变量的地址，在被调函数中通过*+地址来改变主调函数中的变量的值

				void swap(int *p1,int *p2)
				{
					int *p;
					p=p1;
					p1=p2;//p1=&b让p1指向main中的b
					p2=p;//让p2指向main函数中a
				}//此函数中改变的是p1和p2的指向，并没有给main中的a和b赋值
				int main()
				{
					int a=10,b=20;
					swap(&a,&b);
					printf("a=%d b=%d\n",a,b);//结果为1=10  b=20
				}
				总结：要想改变主调函数中变量的值，必须传变量的地址，而且还得通过*+地址去赋值。
					 无论这个变量是什么类型的

				void fun(char *p)
				{
					p="hello kitty";
				} 
				int main()
				{
					char *p="hello world"
					fun(p);
					printf("%s\n",p);//结果为hello world

					return 0;
				}
				分析：
					在fun中改变的是fun函数中的局部变量p，并没有改变main函数中的，变量p还指向hello world					

				void fun(char **q)
				{
					*q="hello kitty";
				}
				int main()
				{
					char *p="hello world"
					fun(&p);
					printf("%s\n",&p);//结果为hello kitty

					return 0;
				}
				总结：要想改变主调函数中变量的值，必须传变量的地址，而且还得通过*+地址去赋值.无论这个变量是什么类型的

			3.传数组：
				给函数传数组的时候，没法一下将数组的内容作为整体传进去。
				只能传数组的地址。 

				传一维数组的地址：
					//void fun(int p[])//形式1
					void fun(int *p)//形式2
					{
						printf("%d\n",p[2]);
						printf("%d\n",*(p+3));//两种调用方式是等价的
					}
					int main()
					{
						int a[10]={1,2,3,4,5,6,7,8};
						fun(a);

						return 0;
					}

				传二维数组的地址：
					//void fun(int p[][4])//形式1
					void fun(int (*p)[4])
					{

					}
					int main()
					{
						int a[3][4]={
						{1,2,3,4}，
						{5,6,7,8},
						{9,10,11,12},
						};

						fun(a);

						return 0;
					}

				传指针数组：
					void fun(char **q)//char q[]
					{
						int i;
						for(i=0;i<3;i++)
							printf("%s\n",q[i]);
					}
					int main()
					{
						char *p[3]={"hello","world","kitty"};//p[0]  p[1]  p[2]  char *
						fun(p);

						return 0;
					}

	2.指针作为函数的返回值
		一个函数可以返回整型数据、字符数据、浮点型的数据，也可以返回一个指针
			char *fun()
			{
				char str[100]="hello world";

				return str;
			}
			int main()
			{
				char *p;
				p=fun();
				printf("%s\n",p);//p虽然指向了返回的地址，但是fun函数用过后就释放掉内存了，所以打印不出hello world
			}
			如果返回的指针指向的内容已经被释放了，返回这个地址，也没有意义了。

		返回静态局部数组的地址
			char * fun()
			{
				static char str[100]="hello world";
				return str;
			}

			int main()
			{
				char *p;
				p=fun();
				printf("%s\n",p);//hello world
			}
			原因是静态数组的内容在函数结束后不会被释放，数据依然存在。

		返回文字常量区的字符串的地址
			char * fun()
			{
				char *str="hello world";

				return str;
			}
			int main()
			{
				char *p;
				p=fun();
				printf("%s\n",p);//结果为hello world ,

				return 0;
			}
			原因是文字常量区的内容不会被释放

		返回堆内存的地址
			char *fun()
			{
				char *str;
				str=(char *)malloc(100);//申请100个地址并强制转换为字符型，再把申请到的100个地址的首地址赋给str
				strcpy(str,"hello world");//将hello world拷贝到str指向的内存中
				
				return str;
			}//动态申请的内存在函数结束后也不会被释放
			int main()
			{
				char *p;
				p=fun();
				printf("%s\n",p);//hello world
				free(p);//释放内存，动态申请的内存只有在free才能够释放
			}
			原因是堆区的内容一直都在，直到free才释放。
			总结：返回的地址，地址指向的内存的内容都存在，才有意义

	3.指针保存函数的地址
		自己定义的函数，在运行程序的时候，会将函数的指令加载到内存的代码段。所以函数也有起始地址。
		c语言规定：函数的名字就是函数的首地址，即函数的入口地址，这样就可以定义一个指针变量来存放
		函数的地址。这个指针变量就是函数的指针变量。
		1.函数指针变量的定义方法
			返回值类型(*函数指针变量名)(形参列表);

			int(*p)(int,int);定义了一个函数指针变量p,p指向的函数必须有一个整型的返回值，有两个整型参数。

			int max(int x,int y)
			{
				
			}

			int main(int x,int y)
			{

			}

			//可以用这个p存放这类函数的地址。

			p=max;
			p=min;

		2.调用函数的方法
			1.通过函数的名字去调函数（最正常的）
				int max(int x,int y)
				{
					return 0;
				}

				int main()
				{
					int num;
					num=mxa(3,5);

					return 0;
				}
				
			2.通过函数指针变量去调用
				int max(int x,int y)
				{

				}
				int main()
				{
					int num;
					int (*p)(int,int);
					p=max;
					num=(*p)(3,5);
				}

		3.函数指针数组
			int (*p[10])(int,int);
			定义了一个函数指针数组，有10个元素p[0]~p[9],每个元素都是函数指针变量，指向的函数，必须有整型的返回值，两个整型参数。

		4.函数指针最常用的地方
			给函数传参	


特殊指针
	1.空类型的指针(void*)
		char*  类型的指针指向char型的数据
		int*   类型的指针指向int型的数据
		float* 类型的指针指向float型的数据

		回顾：对应类型的指针只能存放对应类型的数据地址
		void*  通用指针，任何类型的指针都可以给void*类型的指针变量赋值。
			int *p;
			void *q;
			q=p 是可以的，不用强制类型转换
		举例：
			有个函数叫memset
			void *memset(void *s,int c,size_t n);
			这个函数的功能是将s指向的内存前n个字节，全部赋值为c。
			Memset可以设置字符数组、整型数组、浮点型数组的内容，所以第一个参数就必须是个通用指针
			它的返回值是s指向的内存的首地址，可能是不同类型的地址。所以返回值也得是通用指针
			注意：void*类型的指针变量，在32位系统下，占4个字节

	2.NULL
		空指针：
			char *p=NULL;
			可以认位p哪里都不指向，也可以说p指向内存编号为0的存储单位。在p的四个字节中，存放的是0x00 00 00 00
			一般NULL用在给指针初始化


main函数传参
	#include <stdio.h>

	int main(int argc,char *argv[])
	{
		int i;
		printf("argc=%d\n",argc);
		for(i=0;i<argc;i++)
		{
			printf("argv[%d]=%s\n",i,argv[i]);
		}
		return 0;
	}


strlen
	strlen所作的是一个计数器的工作，它从内存的某个位置（可以是字符串开头，
	中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符
	串结束符'\0'为止，然后返回计数器值(长度不包含'\0')。
	
	格式：
		strlen(字符串);

	源码：
		int strlen(char *s)
		{
			char *p=s;
			while(*p!='\0')
				p++;
			return p-s;
		}

		假设：printf("%d\n",strlen("Hello World!"));

		那么：
			int strlen(char *s)			//“Hello World!”，p指向H的地址
			{
				char *p=s;				//s和p现在是等价关系，p指向H的地址
				while(*p!='\0')			//当指针p指向终止符‘\0’的时候结束循环，第一次为H
					p++;				//每循环一遍指针就指向下一个字符
				return p-s;				//终止符前一个字符地址减去第一个字符的地址得出中间共有多少个字符
			}
			最终返回值为12


指针练习
	1.已知  int a[]={8,1,2,5,0,4,7,6,3,9};
	那么a[*(a+a[3])]的值为 （0）

		解：
			a[*(a+a[3])]
		   =a[*(a+5)]		//a[3]对应的值为5
		   =a[4]			//*(a+5)	a为数组a[0]的地址，加5相当于地址后移5位，相当于a[0+5]==a[5]=4;
		   =0				//a[4]对应的值为0
	
	2.若有以下说明和语句，且0<=i<10，则下面哪个是数组元素的错误引用？	(C)
	int a[]={1,2,3,4,5,6,7,8,9,0};  *p=NULL;  i=0;  p=a;
	A.*(a+i)		B.a[p-a]		C.p+i		D.*(&a[i])

		解：
			p+i		相当于P的地址加i，p的地址为a[0]的地址，a[0]的地址加i得出的地址为a数组元素的地址

	3.若有以下说明和语句,且0<=i<10,则下面哪个是对数组元素地址的正确表示？	(D)
	int a[]={1,2,3,4,5,6,7,8,9,0};  *p=NULL;  i=0;  p=a;
	A.&(a+1)		B.a++		C.&p		D.&p[i]

		解：
			&(a+1)		a+1相当于a[0]+1;为表达式，然后取结果的地址，并不是数组的地址
			a++			数组的名字相当于数组的首地址，是一个常量，不能给常量自加
			&p			指向指针的地址，并不是数组的地址
			&p[i]		p和a是等价的，p[i]相当于a[i],然后取它的地址，最终取的是数组的地址

	4.以下程序的输出结果是哪一项？	(D)
		#include <stdio.h>
		void main()
		{
			int a[12]={1,2,3,4,5,6,7,8,9,10,11,10};		
			int *p[4]={NULL};		
			int i=0;
			for(i=0;i<4;i++)
				p[i]=&a[i*3];
			printf("%d\n",*p[3]);
		}
		A.输出项不合法		B.4		C.7		D.10

	5.对于指向同一数组的指针变量，不能进行哪种运算？	（A）
		A.+		B.-		C.=		D.==
		
		解：
			+		地址+地址得出得地址是无效的
			-		地址-地址得出的是两个地址之间有几个相同类型的元素
			=		指针可以相互赋值的
			==		根据同一个数组的元素地址可以比较大小，所以成立

	6.有以下说明和语句，则p2-p1的值为多少？		(A)
		int a[10]={0},*p1=NULL,*p2=NULL;
		p1=a;
		p2=&a[5];
		A.5		B.6		C.10		D.没有指针与指针的减法

	7.若有以下定义和语句：
		int s[4][5]={0},(*ps)[5]=NULL;
		ps=s;
		则对s数组元素的正确引用形式是		（）
		A.ps+1		B.*(ps+3)		C.ps[0][2]		D.*(ps+1)+3

	8.若有以下定义,int t[3][2]'能正确表示t数组元素地址的表达式是		()
		A.&t[3][2]		B.t[3]		C.t[1]		D.*t[2]

	9.以下程序给数组所有元素输入数据,应在下划线处添入的是		(A)
		A.a+(i++)		B.&a[i+1]		C.a+i		D.&a[++i]
		void main()
		{
			int a[10]={0},i=0;
			while(i<10)
				 scanf("%d",_____);
			...
		}

	10.以下程序的输出结果是		（C）
		A.17		B.18		C.19		D.20
		void main()
		{
			int a[]={2,4,6,8,10},y=1,x=0,*p=NULL;
			p=&a[1];
			for(;x<3;x++)
				y+=*(p+x);		//*(p+x)	相当于a[1+x];
			printf("%d\n",y);
		}

	11.若有以下定义，则对a数组元素的正确引用是		（D）
		int a[5],*p=a;
		A.*&a[5]		B.a+2		C.*(p+5)		D.*(a+2)
		解：
			*&a[5]		先取a[5]的地址，然后再取值，但是数组a只有5个元素，不存在5，
			a+2			a是数组的地址，加2相当于数组地址加2
			*(p+5)		相当于a[0+5]==a[5]，不存在5
			*(a+2)		数组a地址加2，得到a[2]的地址，然后取值，取的是a[2]的值

	12.若有定义：int a[2][3]={0};则对a数组的第i行j列元素地址的正确引用为		（）
		A.*(a[i]+j)		B.(a+i)		C.*(a+j)		D.a[i]+j

	13.若有以下定义,则p+5表示		(A)
		int a[10]={0},*p=a;
		A.元素a[5]的地址					B.元素a[5]的地址
		C.元素a[6]的地址					C.元素a[6]的值
		
	14.下面程序段的运行结果是		（C）
		char *s="abcde";
		s+=2;
		printf("%d",s);
		A.cde		B.字符'c'		C.字符'c'的地址		D.无确定的输出结果 

	15.以下正确的程序段是		（C）
		A.char str[20];							B.char *p;
		  scanf("%s",&str);						  scanf("%s",p);
		C.char str[20];							D.char str[20],*p=str;
		  scanf("%s",&str[2]);					  scanf("%s",p[2]);


					
进阶的老司机——————————————————————————————————————————————————————————————————————————————————————函数——————————————————————————————————————————————————————————————————————————————————————————————————————————			
					
					
函数是什么？					
	函数(function)
		是c语言的功能单位，实现一个功能可以封装一个函数来实现
		是挖成特定任务的独立程序代码			
		语法规则定义了函数的结构和使用方式
		定义函数的时候一切以功能为目的，根据功能去定函数的参数和返回值			
	为什么要使用函数？				
		可以省去编写重复代码的苦闷			
		可以让程序更加模块化，提高代码可读性			
		方便后期修改、完善		

函数的分类
	1.从定义角度分类（即函数是谁实现的）
		1.库函数（C库实现的）
		2.自定义函数（即程序员自己实现的函数）	
		3.系统调用（操作系统实现的函数）

	2.从参数角度分类
		1.有参函数
			函数有形参，可以是一个，或者多个，参数的类型随便，完全取决于函数的功能
			void fun(int a,float b,double c)//形参，待赋值的参数
			{
			}
			fun(1024,1.25f,3.1415);//赋值给形参的数叫做实参

		2.无参函数
			函数没有参数，在形参列表的位置写个void或什么都不写
			int fun(void)
			{
			}

			int fun()
			{
			}

	3.从返回值的角度分类
		1.有返回值的函数
			在定义函数的时候，必须带着返回值类型，在函数体里，必须有return，如果，没有返回值类型，
			默认返回整型
			char fun()//定义了一个返回字符数据的函数
			{
				char b='a';
				return b;	//返回的类型是定义的类型，这里返回char型
			}
			fun()
			{
				return 1;   //因为没有定义返回类型，所以默认返回整型
			}

			注：在定义函数返回值类型的时候，返回值是什么类型的取决于函数的功能。一个函数可以有无数个return
			    但是在最后一个括号前必须加一个return，防止前面条件都不满足而没有返回值

		2.没有返回值的函数
			在定义函数的时候，函数名字前加void
			void fun(形参表)
			{
				语句；
				retuen;			//在函数里不需要return
				语句；
			}
			如果想结束函数，返回到被调用的地方，return;什么都不返回就可以了

					
函数的种类					
	种类				
		内置函数			
			由c语言系统提供		
			需要在程序前面包含定义函数的头文件		
					
				内置函数								所属头文件	
				
				printf			
				scanf									<stdio.h>
				getchar
				putchar
					
				time									<time.h>								表示时间
					
				strcpy									<string.h>								字符串	
				strcmp	
					
		自定义函数			
			1.不带参数		
			2.带参数


函数的声明
	1.概念
		对已定义的函数，进行说明
		函数的声明可以声明多次

	2.为什么要声明
		有些情况下，如果不对函数进行声明，编译器在编译的时候，可能不认识这个函数，因为编译器在编译c程序的
		时候，从上往下编译的。

	3.声明的方法
		什么时候需要声明
			1.主调函数和被调函数在同一个.c文件中
				1.被调函数在上，主调函数在下
					void fun(void)
					{
						printf("Hello word\n");
					}		
					int main()
					{
						fun();//主函数在下，被调用的函数在上的时候就不需要声明
					}
					这种情况下不需要声明

				2.被调函数在下，主调函数在上
					int main()
					{
						fun();
					}
					void fun(void)
					{
						printf("Hello Word!\n");
					}
					编译器从上往下编译，在main函数(主调函数),不认识fun,需要声明
		
		声明的方法
			1.直接声明法
				将被调用的函数的第一行拷贝过去，后面加分号
					void fun(void);			//先简单的声明
					int main()
					{
						fun();
					}
					void fun(void)			//用到的时候再定义
					{
						printf("Hello Word!\n");
					}

			2.间接声明法
				创建一个.h文件，将被调用的函数的第一行拷贝过去，后面加分号，前面加extern,在.c文件中
				调用.h文件就可以使用了
					a.c
					#include"a.h"				//注意，调用自己定义的文件时，文件名不能用尖括号括起来，只能用双引号括起来，尖括号是用来调用自带的头文件，双引号是用来调用自己写的头文件
					int main()
					{
						fun();
					}
					void fun(void)
					{
						printf("Hello World\n");
					}

					a.h
					extern void fun(void);


函数的调用方法
	变量=函数名(实参列表);//带返回值的
	函数名(实参列表);//不带返回值的
	1.有无返回值
		1.有返回值，根据返回值的类型，需要在主调函数中定义一个对应类型的变量，接返回值
			int max(int x,int y)
			{
				return 451;
			}
			int main()
			{
				int num;//需要定义一个和返回值一个类型的变量num来接收max函数的返回值
				num=max(4,8);//4和8是实参，用来给x和y赋值
			}

		2.无返回值的函数，不需要接收返回值
			void fun(void)
			{
				printf("Hello World！\n");
			}
			void main()
			{
				fun();
			}
	
	2.有无形参
		函数名(实参列表);//带形参的
		函数名();//没有形参的

		注意：实参，可以是常量，可以是变量，或者是表达式
		形参是变量，是被调函数的局部变量。


函数总结
	在定义函数的时候，关于函数的参数和返回值是什么情况，完全取决于函数的功能

	使用函数的好处？
	1.定义一次，可以多次调用，减少代码
	2.模块化更好，方便调试程序，而且阅读方便


外部函数
	由自己定义的普通函数，都是外部函数。
	即函数可以在程序中的任何一个文件中调用。


内部函数
	在定义函数的时候，返回值前面加static修饰。
	这样的函数被称为内部（内置）函数
	static限定了函数的作用范围，在定义的.c中有效。


内部函数和外部函数的区别：
	外部函数，在所有的地方都可以调用
	内部函数，只能在所定义的.c中的函数调用。


就近原则：
	在同一作用范围内（局部或全局），不允许变量重名。
	作用范围不同的可以重名。
	局部范围内，重名的全局变量不起作用，会优先使用局部变量。（就近原则）

					
常用的内置函数					
		内置函数						所属头文件									使用说明
	int isupper(int)												返回传入的字符是否为大写字母（0为假，非0为真）
	int islower(int)												返回传入的字符是否为小写字母
	int isalpha(int)					 ctype.h					返回传入的字符是否为字母（a-z|A-Z）
	int isdigit(int)												返回传入的字符是否数字
	int toupper(int)												返回对应的大写字母
	int tolower(int)												返回对应的小写字母

	double ceil(double)												向上取整（进一）
	double floor(double)											向下取整（去尾）
	double sqrt(double)					  math.h					返回传入数字的平方根
	double pow(double,double)										返回某个数的n次幂
	int abs(int)													返回绝对值

	int srand(unsigned int)											设置随机数生成种子
	int rand(void)						 stdlib.h					随机产生一个0~32767的数字，一般与srand联用
	void exit(int)													终止程序
	void system(const char*)										可以执行dos命令


人在囧途——————————————————————————————————————————————————————————————————————————————————————内存——————————————————————————————————————————————————————————————————————————————————————————————————————————
				
					
内存的分区
	1.内存：物理内存、虚拟内存
		物理内存：实实在在存在的储存设备

		虚拟内存：操作系统虚拟出来的内存

		操作系统会在物理内存和虚拟内存之间做映射					

		在32位系统下，每个进程的寻址范围是4G，0x00 00  ~  0xff ff   32个0到32个1之间

		在写应用程序的，我们所看到的都是虚拟地址	

	2.在运行程序的时候，操作系统会将虚拟内存进行分区
		1.堆
			在动态申请内存的时候，在堆里开辟内存

		2.栈			
			主要存放局部变量

		3.静态全局区
			1.未初始化的静态全局区
				静态变量(定义变量的时候，前面加static修饰)，或全局变量，没有初始化单独，存在此区
			
			2.初始化的静态全局区
				全局变量、静态变量、赋过初值的，存放在此区
		
		4.代码区
			存放程序代码

		5.文字常量区
			存放常量的。


普通的全局变量
	概念：
		在函数外部定义的变量
		int num=100;//就是一个全局变量
		int main()
		{
			return 0;
		}

	作用范围：
		全局变量的作用范围，是程序的所有地方
		值不过用之前需要声明。声明方法 extern int num;
		注意声明的时候，不要赋值
	
	生命周期：
		程序运行的整个过程一直存在，直到程序结束

	注意：定义普通的全局变量的时候，如果不赋初值，它的值默认为0


静态全局变量    static
	概念：
		定义全局变量的时候，前面用static修饰。
		static int num=100;//num就是一个静态全局变量
		int main()
		{
			return 0;
		}

	作用范围：
		static 限定了静态全局变量的作用范围
		只能在它定义的.c（源文件）中有效

	声明周期：
		在程序的整个运行过程中，一直存在。

	注意：定义静态全局变量的时候，如果不赋初值，它的值默认为0


普通的局部变量
	概念：
		在函数内部定义的，或者复合语句中定义的变量
		int main()
		{
			int num;//局部变量

			{		//在c语言中，一对大括号被称为复合语句
				int a;//局部变量
			}
		}

	作用范围：
		在函数中定义的变量，仅在所定义的函数中有效
		在复合语句中定义的，仅在复合语句中有效
			复合语句：
				把多个语句用括号{}括起来组成的一个语句称复合语句。
				在程序中应把复合语句看成是单条语句，而不是多条语句
				{
					x=y+z;
					a=b+c;
					printf("%d%d",x,a);
				}
				是一条复合语句。复合语句内的各条语句都必须以分号“;”结尾，
				此外，在括号“}”外不能加分号。

	生命周期：
		第一次调用函数的时候，开辟空间赋值，函数结束后，释放，以后再调用的时候，
		再为其开辟空间赋值。


静态的局部变量
	概念：
		定义局部变量的时候，前面加static修饰
	
	作用范围：
		在它定义的函数或复合语句中有效。
	
	生命周期：
		第一次调用函数的时候，开辟空间赋值，函数结束后，不释放，以后再调用的时候，
		就不再为其开辟空间，也不赋值，用的是以前的那个变量。
		void fun()
		{
			static int num=0;
			num++;
			printf("num=%d\n",num);
		}

		void main()
		{
			fun();
			fun();
			fun();
		}
		结果：
			num=1
			num=2
			num=3


注意：
	1.定义普通局部变量，如果不赋初值，它的值是随机的。
	2.定义静态局部变量，如果不赋初值，它的值为0。
	3.普通全局变量，和静态全局变量如果不赋初值，它的值为0.


1.内存大小转换
    2的10次方 = 1024
    1G  = 1024M
    1M  =  1024KB
    1KB = 1024B(Byte)
    1Byte = 8 bit



2.内存地址用4位16进制和8位16进 制表示的区别。
    经常可以看到某些书籍上写的内存地址0x0001，在另外一些书籍上写的内存地址又变成了0x00000001，
    其实都是表示的编号为1的内存地址,在本质上并没有明显区别

    内存地址只是一个编号，代表一个内存空间,在计算机中存储器的容量是以字节为基本单位的,
    也就是说一个内存地址代表一个字节（8bit）的存储空间。
        例如：
            地址0x0001中的数据为1111 1111，也就是说数据1111 1111的编号为0x0001
            地址0x00000001中的数据为1111 1111，也就是说数据1111 1111的编号为0x00000001
            所以说用4位16进制表示的内存地址和用8位16进制表示的内存地址，其实都是代表一个8bit的存储空间而已

    [0x0000]---->[8bit空间]
    [0x0001]---->[8bit空间]
    [0x0002]---->[8bit空间]
    [0x0003]---->[8bit空间]
    [0x0004]---->[8bit空间]

    [0x00000000]---->[8bit空间]
    [0x00000001]---->[8bit空间]
    [0x00000002]---->[8bit空间]
    [0x00000003]---->[8bit空间]
    [0x00000004]---->[8bit空间]
    至于说为什么会出现一种是用4位十六进制表示内存地址，另一种用8位十六进制表示内存地址，
    那是根据不同的硬件环境来的。个人理解：
    有些CPU只能寻址16位（16根地址线），所以用4位十六进制表示地址就够用了。
    有些CPU只能寻址32位（32根地址线），所以用8位十六进制。


3.内存
    程序和数据平常存储在硬盘等存储器上，不管你开机或关机了，它们都是存在的，不会丢失。
    硬盘可以存储的东西很多，但其传输数据的速度较慢，所以需要运行程序或打开数据时，这些数据
    必须从硬盘等存储器上先传到另一种容量小但速度快得多的存储器，之后才送入CPU进行执行处理。
    这中间的存储器就是内存。

    无论何种存储器，软盘、硬盘、光盘或者内存，都有地址。因为它们要存储数据，所以就必须按一定
    的单位的数据分配一个地址。有了地址，程序才能找到这些数据。

    例如：
        如果让计算机在内存里记住“邵伟业”这个名字，可以示意为：

                邵       |       伟       |        业
          1000H | 1001H  | 1002H | 1003H  |  1004H | 1005H

        在第一行中，每一格表示一段内存，而格子里的内容是这段内容记下的数据；
        第二行中，每一格内数字就是对应的内存的地址，
        一个中文占两个字节，也就是占16bit（储存的方式为2进制，汉字编码成2进制后再进行储存，
        世界通用的有UTF-8，包含全世界国家需要的字符，）

        如果让计算机再内存中记住“ABC”，可示意为：

              A    |    B    |    C
            2000H  |  2001H  |  2002H
        一个英文或数字占一个字节，也就是8bit，多用ASCLL码编码

        邵字占两个字节，两个字节都有自己单独的地址，而如果想调用邵字，它的地址就为1000H，
        若数据占用多个字节，则以第一个字节的地址来表示数据的地址

        1000H只是邵字的地址，而数据都是以二进制储存的，下面则是用UTF-8中，邵字的编码

                            邵
            1001    0000    |   1011    0101
                1000H       |       1001H

        在UTF-8中，邵字的编码为1001000010110101,分别储存在地址1000H和1001H中

        下面则是在ASCLL码中，A的编码
                          A
                    0100    0001
                        1000H
        
        在ASCLL中，A的编码为0100 0001

        第一行分别是邵和A，它是给人看的
        第二行则是一串的0和1，这才是计算机内存中实际存储的数据
        第三行是内存的地址，并不是每个0和1都占有单独的地址，而是每8个才有一个地址，也就是说每个地址都有8bit的空间


4.总结：
        内存地址是内存当中存储数据的一个标识，并不是数据本身，通过内存地址可以找到内存当中存储的数据。


——————————————————————————————————————————————————————————————————————————————————————预处理——————————————————————————————————————————————————————————————————————————————————————————————————————————

C语言编译过程
	1.预处理
		将.c中的头文件展开、宏展开
		生成的文件是.i文件
	2.编译
		将预处理之后的.i文件生成.s汇编文件
	3.汇编
		将.s编译文件生成.o目标文件
	4.链接
		将.o文件链接成目标文件


include 
	#include<>//用尖括号包含头文件，在系统指定的路径下找头文件
	#include“”//用双引号包含头文件，先在当前目录下找头文件，找不到再到系统指定的路径去找。
	
	注意：
		include经常用来包含头文件，可以包含.c文件，但是尽量不要包含.c，因为include包含的文件会在
		预编译被展开，如果一个.c被包含多次，展开多次，会导致函数重复定义。所以不要包含.c文件

		预处理只是对include 等预处理操作进行处理并不会进行语法检查，这个阶段有语法错误也不会报错
		第二阶段才进行语法检查。


define
	定义宏用define去定义
	宏是在预编译的时候进行替换。
	宏定义的作用范围：从定义的地方到本文件末尾。

	注意：宏定义后面没有分号。

	1.不带参宏
		#define    PI    3.14			//define 声明，PI宏名字(一般为大写)，3.14宏的值
		在预编译的时候如果代码中出现了PI就用3.14去替换。
		宏的好处：只要修改宏定义，其他地方在预编译的时候就会重新替换。
		例：
			#define PI 3.1415926

			int main()
			{
				printf("%lf\n",PI);
				return 0;
			}

	2.带参宏
		注意：
			带参宏的形参a和b没有类型名，S（2，4）将来在预处理的时候替换成实参替代字符串的形参，
			其他字符保留，2*4

		#define S(a,b) (a)*(b)//a*b分别加括号是因为优先级问题，如果不加括号，S(2+3,5)带入后就是S(2+3*5),加上括号就可以避免这类问题S((2+3)*5)

		int main()
		{
			int num;
			num=S(2,4);

			return 0;
		}

	3.带参宏和带参函数的区别
		带参宏被调用多少次就会展开多少次，执行代码的时候没有函数调用的过程，不需要压栈弹栈。所以带
		参宏，是浪费了空间，因为被展开多次，节省时间。

		带参函数，代码只有一份，存在代码段，调用的时候去代码段取指令，调用的时候要，压栈弹栈。有个
		调用的过程

		所以说，带参函数是浪费了时间，节省了空间

	如果想在中间终止宏的定义范围
		#undef PI //终止PI的作用


选择性编译
	1.ifdef
		#ifdef AAA
			代码段一
		#else
			代码段二
		#endif

		如果在当前.c ifdef上边定义过AAA，就编译代码段1，否则编译代码段二

		注意和if else语句的区别，if else 语句都会被编译，通过条件选择性执行代码而选择性编译，
		只有一块代码被编译

		例：
			#define AAA

			int main()
			{
				#ifdef AAA
					printf("hello world\n");//如果定义了AAA则编译这块代码，else不参与编译
				#else
					printf("hello Rise\n");//如果没定义AAA者编译这块代码，ifdef不参与编译
				#endif//结束ifdef

				return 0;
			}

	2.ifndef
		#ifndef AAA		//如果没有定义AAA
			代码段一
		#else			//否则
			代码段二
		#endif			//结束ifndef
		
		和ifdef互补。
		这种方法，经常用在防止头文件重复包含。

	3.if 表达式
		#if 表达式
			程序段一
		#else
			程序段二
		#endif

		如果表达式为真，编译第一段代码，否则编译第二段代码
		选择性编译都是再预编译阶段干的事情。


————————————————————————————————————————————————————————————————————————————————————静态编译和动态编译———————————————————————————————————————————————————————————————————————————————————————————————————————————	

静态库
	1.动态编译
		动态编译使用的是动态库文件进行编译
		编译时不对动态库做任何操作，只有运行可执行程序时，才会调用动态库，可执行程序体积较小

	2.静态编译
		静态编译使用的静态库文件进行编译
		把静态库打包到可执行程序里，可执行程序体积会大很多
	
	3.静态编译和动态编译的区别
		1.使用的库文件的格式不一样
			动态编译使用的动态库，静态编译使用静态库

		注意：
			1.静态编译要把静态库文件打包编译到可执行程序中。
			2.动态编译不会把动态库文件打包编译到可执行程序中，它只是编译链接关系


———————————————————————————————————————————————————————————————————————————————————字符串处理函数————————————————————————————————————————————————————————————————————————————————————————————————————————————	

测字符串长度函数
	头文件:#include <string.h>
	函数定义：size_t strlen(const char *s);
	函数功能：
		测字符指针s指向的字符串中字符的个数，不包括'\0'
		返回值：字符串中字符个数
	#include <stdio.h>
	#include <string.h>

	int main()
	{
		char str1[20]="hello";//其实只用了6个元素，hello+\0
		char *str2="hello";//保存h的地址，hello保存在文字常量区
		printf("%d\n",sizeof(str1));//20	测的是数组的大小，一共20个字节
		printf("%d\n",sizeof(str2));//4		测的是str2本身的大小，共4个字节用于存放变量地址
		printf("%d\n",strlen(str1));//5		测的是字符串的个数，不包含\0
		printf("%d\n",strlen(str2));//5		测的是字符串的个数，不包含\0

		return 0;
	}
	sizeof是个关键字，测量数据的占用内存空间大小
	strlen是个库函数，测的是字符串的个数


字符拷贝函数
	头文件:#include <string.h>
	1.strcpy函数
		函数的定义:char *strcpy(char *dest,const char *src);
		函数的说明：
			拷贝src指向的字符串到dest指针指向的内存中，'\0'也会拷贝
		函数的返回值：
			目的内存的地址
		注意：
			在使用此函数的时候，必须保证dest指向的内存空间足够大，否则会出现内存污染。
		#include <stdio.h>
		#include <string.h>
		void strcpy_0()
		{
			char buf[100]="aaaaaaaaaaaaaaa";
			strcpy(buf,"helloworld");
			printf("%s\n",buf);
		}
		结果是helloworld
		验证了会拷贝'\0'

	2.strncpy函数
		char *strncpy(char *dest,const char *src,size_t n);
		函数的说明：
			将src指向的字符串前n个字节，拷贝到dest指向的内存中
		函数的返回值：
			目的内存的地址
		注意：
			1、strncpy不拷贝'\0'
			2、如果n大于src指向的字符串中的字符串个数，则在dest后填充n-strlen(src)个'\0'
		#include <stdio.h>
		#include <string.h>
		int main()
		{
			char buf[100]="aaaaaaaaaaaaaaa";
			strncpy(buf,"helloworld",5);
			printf("%s\n",buf);
		}
		结果为helloaaaaaaaaaa
		验证了不拷贝'\0'

		#include <stdio.h>
		#include <string.h>
		void main()
		{
			char buf[100]="aaaaaaaaaaaaaaa";
			strncpy(buf,"hell0",10);//不够的用'\0'填充
			printf("%s\n",buf);
		}
		结果是hello
		验证了如果n大于src指向的字符串中的字符串个数，则在dest后填充n-strlen(src)个'\0'


字符串追加函数
	1.strcat函数
		头文件:#include <string.h>
		函数定义：char *strcat(char *dest,const char *src);
		函数功能：
			strcat函数追加src字符串到dest指向的字符串的后面。追加的时候会追加'\0'
			将src字符串拷贝到dest字符串的后面
		注意：
			保证dest指向的内存空间足够大。
		#include <stdio.h>
		#include <string.h>
		int main()
		{
			char str[20]="aa\0aaaaaaaaaaaaa";
			char *src = "hello";
			strcat(str,src);
			printf("%s\n",str);
		}
		结果：aahello
		检测到'\0'后，系统就判断为字符结束，然后把src拷贝到\0开始的位置
		验证了追加字符串的时候追加'\0'

	2.strncat函数
		char *strncat(char *dest,const char *src,size_t n);
		追加src指向的字符串的前n个字符，到dest指向的字符串的后面。
		注意如果n大于src的字符个数，则只将src字符串追加到dest指向的字符串的后面
		追加的时候就会追加'\0'
		#include <stdio.h>
		#include <string.h>
		int main()
		{
			char str[20]="aa\0aaaaaaaaaaaaa";
			char *src = "hello";
			strncat(str,src,3);
			printf("%s\n",str);
		}


字符串比较函数
	头文件：#include <string.h>
	1.strcmp函数
		函数定义：
			int strcmp(const char *s1,const char *s2);
		函数的说明：	
			比较s1和s2指向的字符串的大小，
			比较的方法：逐个字符去比较ascll码，一旦比较出大小就返回。
			如果所有字符都一样，则返回0

		返回值：
			如果s1指向的字符串大于a2指向的字符串 返回1
			如果s1指向的字符串小于a2指向的字符串 返回-1

	2.strncmp函数
		函数定义：
			int strncmp(const char *s1,const char *s2,size_t n);
		函数的说明：
			比较s1和s2指向的字符串中的前n个字符
		例子：
			#include <stdio.h>
			#include <string.h>

			int main()
			{
				char *str1 = "hello world";
				char *str2 = "hello kitty";
				printf("%d\n",strcmp(str1,str2));
				printf("%d\n",strncmp(str1,str2,5));//只比较前5个字符
				return 0;
			}


字符串查找函数
	头文件:
		#include <string.h>

	1.strchr函数
		函数定义:
			char *strchr(const char *s,int c);

		函数说明：
			在字符指针s指向的字符串中，找ascii码为c的字符

		注意：
			是首次匹配，如果说s指向的字符串中有多个ASCII为c的字符，则找的是第一个字符

		返回值：
			找到了返回找到的字符的地址，
			找不到返回null，

	2.strrchr函数
		函数定义：
			char *strrchr(const char *s,int c);

		函数的说明:
			末次匹配
			在s指向的字符串中，找最后一次出现的ASCII为c的字符
		
		返回值：
			末次匹配的字符的地址。


字符串匹配函数
	头文件：
		#include <string.h>
	
	函数的定义：
		char *strstr(const char *haystack,const char *needle);

	函数说明:
		在haystack指向的字符串中查找needle指向的字符串，也是首次匹配

	返回值：
		找到了：找到的字符串的首地址
		没找到：返回NULL

	例子：
		#include <stdio.h>
		#include <string.h>

		int main()   
		{
			char str1[30]="adfa#$#hfjsg#$#addhfh";
			char ch='#';
			char str2[4]="#$#";

			printf("str1中，第一次出现'#'的地址为：%p\n",strchr(str1,ch));			//在str1中查找‘#’，返回第一次出现的地址
			printf("str1中，第一次出现'#$#'的地址为：%p\n",strstr(str1,str2));		//在str1中查找‘#$#’，返回第一次出现的地址

			return 0;
		}


字符串转换数值
	头文件:#include <stdlib.h>
	1.atoi
		函数的定义：
			int atoi(const char *nptr);

		函数功能:
			将nptr指向的字符串转换成整数，返回

		例：
			int num;
			num=atoi("123");
			则num的值为123
	
	2.atol
		函数的定义：
			long atol(const char *nptr);
		
		函数的功能：
			将nptr指向的字符串转换成长整型，返回

		例：
			long num;
			num=atol("123");
			则num的值为123

	3.atof
		函数的定义：
			double atof(const char *nptr);

		函数的功能：
			将nptr指向的字符串转换成单精度浮点型，返回

		例如：
			double num;
			num=atol("123.456");
			则num的值为123.456


字符串切割函数：
	头文件：
		#include <string.h>

	函数定义：
		char *strtok(char *str,const char *delim);

	函数的功能：
		字符串切割，按照delim指向的字符串中的字符，切割str指向的字符串。
		其实就是在str指向的字符串中发现了delim字符串中的字符，就将其变成'\0',
		调用一次strtok只切割一次，切割一次后，再去切割的时候strtok的第一个参数传
		NULL，意识是接着上次切割的位置继续切割

	返回值：
		返回切出来的字符串的首地址

	注意:
		如果str字符串中出现了连续的几个delim中的字符串，则只将第一个字符变成'\0'

	例子：
		#include <stdio.h>
		#include <string.h>

		int main()
		{
			char name[100]="chenjianzhong:wangchunyu,tanggaoyuan;lianghongyu,shaoweiye:like,gushiyu";
			char *p[8];//共存放7个，第8个用于存放'\0'
			int i=0,j=1;

			p[i]=strtok(name,":,;");//在name数组中找到;||,||:找到其中一个就把找到的字符替换为'\0'
			printf("p[%d]=%s\n",i,p[i]);
			while(p[i]!=NULL)   //如果切完再去切就返回NULL，若没切完就继续切
			{
				i++;
				p[i]=strtok(NULL,",:;");//strtok函数有记忆性，可以记住上一次切到的位置，输入NULL就会从上一次替换掉的NULL开始
			}
			for(;j<i;j++)
				printf("p[%d]=%s\n",j,p[j]);

			return 0;
		}


格式化字符串操作函数：
	1.sprintf
		函数的定义：
			int sprintf(char *buf,const char *format,...);

		函数的功能：
			输出到buf指定的内存区域。

		例如：
			char buf[20];
			sprintf(buf,"%d:%d:%d",2013,10,1);//将结果输出到buf指定的内存区域中，并不会输出到屏幕上
			printf("buf=%s\n",buf);//将结果输出到屏幕上

	2.sscanf
		函数的定义：
			int sscanf(const char *buf,const char *format,...);

		函数的功能：
			从buf指定的内存区域中读入信息

		例：
			int a,b,c;
			sscanf("2013:10:1","%d:%d:%d",&a,&b,&c);//不从键盘获取输入了，把第一对双引号内的数据以第二对双引号内的格式储存到a,b,c中
			printf("%d  %d  %d\n",a,b,c); 

		sscanf高级用法：
			1.跳过数据：%*s或%*d
				作用：
					%*s		加一个'*'代表着跳过字符串
					%*d		跳过一个整数
				例：
					sscanf("1234 5678","%*d %s",buf);//%*d先跳过1234，然后跳过空格，然后%s获取一个字符串，把5678保存到buf内

			2.读指定宽度的数据：%[width]s
				例：
					char buf[10];
					sscanf("12345678","%4s",buf);//从字符串中获取字符串，只要4个字节，存放在buff中
					printf("%s\n",buf);
					int num;
					sscanf("12345678","%3d",&num);//也可以输入整型，只取3字节
					printf("%d\n",num);

					sscanf("12345678","%*3d %3d",&num);//跳过3个整型，然后再取3个字节
					printf("%d\n",num);
			
			3.支持集合操作
				只支持获取字符串
				%[a-z]表示匹配a到z中任意字符（尽可能多的匹配）
				例：
					char buf[20];
					sscanf("hfdka32KHHfsa,/rqrh","%[a-z]",buf);//从字符串中获取输入，只要'a'和'z'之间的字母范围内的，就终止了
					printf("%s\n",buf);//若遇到不是a-z之间的数就会终止

					sscanf("hfdka32KHHfsa,/rqrh","%*[a-z] %5s",buf);//可以配合*号来使用，跳过a-z之间的字符
					printf("%s\n",buf);

				%[aBc]匹配 a、B、c中的一员，贪婪性		只要读到不是aBc中的一员就不再读取
				%[^aFc]匹配非aFc的任意字符，贪婪性		读到aFc中任意一个就立刻停止，不再读取
				%[^a-z]表示读取除a-z以外的所有字符		读到a-z后立刻停止，不再读取

				例：
					若有afa23#fak790@gfasdfu87字符串，要求只要#和@之间的字符串

					char buf[20];
					sscanf("afa23#fak790@gfasdfu87","%*[^#] %S %[^@]",buf);//1.跳过不是＃号的字符，搜到#号后停止，2.%*c跳过一个字符，把#跳过3.取不是@的字符，遇到@后停止
					printf("%s\n",buf);


const
	1:修饰普通变量，代表只读的意思
		const int a=100;//定义了一个只读变量a值为100
		以后在程序中，不能再给a赋值了
		a=200;//错误的，a只读，不可以写

	2.const修饰指针
		(1)、const char *str
			意思是str指向的内存的内容不能通过str来修改
			用来保护str指向的内存的内容
			但是str的指向是可以改变的
			char *strcpy(char *dest,const char *src);

		(2)、char *const str
			意思是str是只读的变量，str不能指向别的地方，
			但是str指向的内存的内容，是有可能可以修改的

		(3)、const char *const str
			str不能指向别的地方，str指向的内存的内容也不能通过str去修改


puts
	函数的定义：
		int puts(const char *string);

	函数功能：
		将字符串输出到终端（屏幕），puts函数一次只能输出一个字符串，字符串可以包括转义字符。

	例：
		char string[] = "This is an example output string\n";
   		puts(string);//相当于printf("%s\n",string);

	注意：
		puts输出字符串时要遇到'\0'也就是字符结束符才停止。
		puts()函数只能输出字符串, 不能输出数值或进行格式变换。
		可以将字符串直接写入puts()函数中。puts("Hello, world！");
		puts 和 printf的用法一样,puts()函数的作用与语句“printf("%s\n",s);的作用相同。
		puts在输出字 符串后会自动输出一个回车符。


———————————————————————————————————————————————————————————————————————————————————结构体————————————————————————————————————————————————————————————————————————————————————————————————————————————	

前面学过一种结构体————数组

构造类型：
	不是基本类型的数据结构也不是指针，它是由若干个相同或不同类型的数据构成的集合

	描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算
	有时我们需要将不同类型的数据组合成一个有机的整体，以便于引用。
	如：
		一个学生有学号/姓名/性别/年龄/地址等属性
		int num;
		char name[20];
		char sex;
		int age;
		char addr[30];
		显然单独定义以上变量比较繁琐，数据不便于管理	


结构体类型的概念及定义
	概念：
		结构体是一种构造类型的数据结构
		是一种或多种基本类型或构造类型的数据的集合。
		结构体和数组等构造类型只是对数据打包不改变数据结构本身属性，打包是为了更好管理数据

	结构体类型的定义方法
		咱们在使用结构体之前必须先有类型，然后用类型定义数据结构这个类型相当于一个模具
		1.先定义结构体类型，再去定义结构体变量
			struct 结构体类型名{
				成员列表
			};
			例：
				struct stu{				//先声明结构体类型
					int num;
					char name[20];
					char sex;
				};
				//有了结构体类型后，就可以用类型定义变量了
				void main()
				{
					struct stu  lucy,boob,lilei;//定义了三个struct stu类型的变量,每个变量都有三个成员，分别是num name sex
				}
				现在可以暂时认为结构体变量的大小是它所有成员之和
				lucy,boob,lilei储存在栈区，因为他们是局部变量
				声明的时候是不占用空间的，只有在定义结构体变量后才会占用空间

		2.在定义结构体类型的时候顺便定义结构体变量，以后还可以定义结构体变量
			struct 结构体类型名{
				成员列表
			}结构体变量1,变量2;
			void main()
			{
				struct 结构体类型名 变量3,变量4；
			}
			例：
				struct stu{				//先声明结构体类型
					int num;
					char name[20];
					char sex;
				}licy,boob,lilei;
				lucy,boob,lilei储存在数据段里，因为他们是全局变量
				
		3.在定义结构体类型的时候，没有结构体类型名，顺便定义结构体变量，因为没有类型名，所以以后不能再定义相关类型的数据了
			struct{
				成员列表;
			}变量1,变量2;
			例：
				struct{
					int num;
					char name[20];
					char sex;
				}lucy,bob;
				以后没法再定义这个结构体类型的数据了，因为没有类型名

		4.最常用的方法
			通常先将一个结构体类型重新起个类型名，用新的类型名替代原先的类型
			例：
				struct stu{			//先用结构体类型定义变量
					int nnum;
					char name[20];
					char sex;
				}bob;

				步骤2:新的类型名替代变量名
				struct stu{
					int num;
					char name[20];
					char sex;
				}STU;

				步骤3：在最前面加typedef
				typedef struct stu{
					int num;
					char name[20];
					char sex;
				}STU;

				注意：
					步骤1和步骤2，在草稿上做的，步骤3是程序中的代码
				
				以后STU就相当于struct stu
				STU lucy;和struct stu lucy;是等价的。


结构体类型的使用
	结构体变量，是个变量，这个变量是若干个数据的集合
	在定义结构体变量之前首先得有结构体类型，然后再定义变量
	在定义结构体变量的时候，可以顺便给结构体变量赋初值，被称为结构体的初始化
	结构体变量初始化的时候，各个成员顺序初始化
	结构体类型相同是可以相互赋值的
	struct student{
		int num;
		char name[20];
		char sex;
		int age;
		char addr[30];
	};
	void main()
	{
		struct student b;		//声明结构体，结构体类型名，结构体变量名={值1,值2,,,,...}；
	}
	方法1：
		定义结构体变量时，直接进行赋值
		struct student b={25,"hello world!",'x',10,"Rise"};
		这个方法和数组特别像

	方法2:
		struct student b；
		b.num=10;			//结构体变量名 . 结构体成员名
		.为成员运算符
		不仅知道访问的是哪个结构体，还知道访问的是哪个成员
		对数组进行赋值时需要用到strcpy函数
		strcpy(b.name,"Rise");


结构体数组
	结构体数组是个数组，由若干个相同类型的结构体变量构成的集合
	1.结构体数组的定义方法
		struct 结构体类型名 数组名[元素个数];
		例：
			struct stu{
				int num;
				char name[20];
				char sex;
			};
			struct stu edu[3];//定义了一个struct stu类型的结构体数组edu，这个数组有3个元素分别是edu[0]、edu[1]、edu[2]


结构体指针
	即结构体的地址，结构体变量存放内存中，也有起始地址，定义一个变量来存放这个地址，那这个变量就是结构体指针变量。
	1、结构体指针变量的定义方法：
		struct 结构体类型名 * 结构体指针变量名;

		struct stu{
			int num;
			char name[20];
		};  

		struct stu *p；//定义了一个struct stu *类型的指针变量
		变量名 是p，p占4个字节，用来保存结构体变量的地址编号

		struct stu boy;
		p=&boy;
	2.访问结构体变量的成员方法：
		boy，num=101;//可以，通过结构体变量名 成员运算符 成员名
		(*p).num=101;//可以，*p相当于p指向的变量boy
		p->num=101;//可以，指针->成员名，->为指向运算符
		通过结构体指针来引用指针指向的结构体的成员，前提是指针必须先指向一个结构体变量
	3.结构体指针经常用到的地方：
		1.保存结构体变量的地址
			typedef struct stu{
				int num;
				char name[20];
				float score;
			}STU;
			int main()
			{
				STU *p,lucy;
				p=&lucy;
				p->num=101;
				strcpy(p->name,"baby");
				//p->name="baby";//错误，因为p->name相当于lucy,name是一个常量，无法给常量赋值
				return 0;
			}

		2.传结构体变量的地址
			#include <stdio.h>
			#include <string.h>
			tyoedef struct stu{
				int num;
				char name[20];
				float score;
			}STU;
			void fun(STU *p)
			{
				p->num=101;
				(*p).score=87.6;
				strcpy(p->name,"lucy");
			}
			int main()
			{
				STU girl;
				fun(&girl);
				printf("%d %s %f\n",girl.num,girl.name,girl.score);
				return 0;
			}

		3.传结构体数组的地址
			结构体数组，是由多个相同类型的结构体变量构成的。存放在内存里，也有起始地址，其实就是第0个结构体的地址
				#include <stdio.h>
				#include <string.h>
				typedef struct stu{
					int num;
					char name[20];
					float score;
				}STU;
				void fun(STU *p)
				{
					p[1].num=101;
					(*(p+1)).score=88.6;
				}
				int main()
				{
					STU edu[3];
					fun(edu);
					printf("%d %f\n",edu[1].num,edu[1].score);

					return 0;
				}
			注意：
				结构体变量的地址编号和结构体第一个成员的地址编号相同，但指针的类型不同。
				结构体数组的地址就是结构体数组中第0个元素的地址


结构体内存分配
	1.结构体内存分配
		结构体变量大小是它所有成员之和。
		因为结构体变量是所有成员的集合。
			#include <stdio.h>
			struct stu{
				int num;
				int age;
			}lucy;
			int main()
			{
				printf("%d\n",sizof(lucy));//结果为8 

				return 0;
			}
		但是在实际中给结构体变量分配内存的时候，是有规则的
			#include <stdio.h>
			struct stu{
				char sex;
				int age;
			}lucy;
			int main()
			{
				printf("%d\n",sizeof(lucy));//结果为8

				return 0;
			}
			给结构体变量分配内存的时候，会去结构体变量中找基本类型的成员
			哪个基本类型的成员占字节数多，就以它大小为单位开辟内存，在gcc
			中出现了double类型的，除外
				1.成员中只有char型数据，以1字节为单位开辟内存。
				2.成员中出现了short int类型的数据，没有更大字节数的基本类型数据。以2字节为单位开辟内存
				3.出现了int float没有更大字节的基本类型数据的时候以4字节为单位开辟内存。
				4.出现了double类型的数据
					情况1：
						在vc里，以8字节为单位开辟内存。
					情况2：
						在gcc里，以4字节为单位开辟内存。
					无论是哪种环境，double型变量都占8字节。

			注意：
				如果在结构体中出现了数组，数组可以看成多个变量的集合。
				如果出现指针的话，没有占字节数更大的类型的，以4字节为单位开辟内存
				在内存中存储结构体成员的时候，按定义的结构体成员的顺序存储。
				struct stu{
					char sex;
					int age;
				}lucy;
				lucy的大小是4的倍数
	2.字节对齐
		1.自动对齐
			字节对齐可以用空间来换时间，提高cpu读取数据的效率
			1.char 1字节对齐，即存放char型的变量，内存单元的编号是1的倍数即可。
			2.short int 2字节对齐，即存放short int型的变量，起始内存单元的编号是2的倍数即可
			3.int 4字节对齐，即存放int 型的变量，起始内存单元的编号是4的倍数即可。
			4.long int 在32位平台下，4字节对齐，在64位平台下，8字节对齐
			5.float 4字节对齐，即存放float型的变量，起始内存单元的编号是4的倍数即可
			6.double
				vc环境下
					8字节对齐，即存放double型变量的起始地址，必须是8的倍数，double类型的变量占8字节
				gcc环境下
					4字节对齐，即存放double型变量的起始地址，必须是4的倍数，double类型的变量占8字节
			
			注意：
				当结构体成员中出现数组的时候，可以看成多个变量。
				开辟内存的时候，从上向下依次按成员在结构体中的位置顺序开辟空间

		2.指定对齐：
			使用#pragma pack改变默认对齐原则
			格式：
					//value指定的齐的值
			例：
				#pragma pack(2)
				struct stu{
					char a;
					int b;
				};//以2个字节为单位开辟内存
			注意：
				1.value只能是：1248等
				2.指定对齐值与数据类型对齐值相比较取小值，为单位开辟内存

位段（位域）
	在结构体中，以位为单位的成员，称之为位段（位域）。
		struct packed_data{
			unsigned int a:2;
			unsigned int b:6;
			unsigned int c:4;
			unsigned int d:4;
			unsigned int i;
		}data;

		a  b      c    d                    i
		2  6      4    4    16              32

		注意：
			不能对位段成员取地址

		例：
			#include <stdio.h>
			struct packed_data{
				unsigned int a:2;
				unsigned int b:6;
				unsigned int c:4;
				unsigned int d:4;
				unsigned int i;
			}data;
			int main()
			{
				printf("%d\n",sizeof(data));
				printf("%p\n",&data);
				printf("%p\n",&(data.i));

				return 0;
			}
			位段注意：
				1.对于位段成员引用如下：
					data.a=2
					赋值时 ，不要超出位段定义的范围；
					如段成员a定义为2位，最大值为3即(0b11)2
					所以data.a=5,就会取5的低两位进行赋值0b101
				2.位段成员的类型必须指定为整形或字符型
				3.一个位段必须存放在一个存储单元中，不能跨两个单元
				  第一个单元空间不能容纳下一个位段，则该空间不用，
				  而从下一个单元起存放该位段
					struct stu{
						char a:7;
						char b:7;
						char c:2;
					}temp;//占3字节,b不能跨存储单元存储
					不能取temp.b得地址，因为b可能不够1字节，不能取地址
				4.位段的长度不能大于存储单元的长度
					1.char型位段不能大于8位
					2.short int型位段不能大于16位
					3.int的位段，位段不能大于32位
					4.long int的位段，位段不能大于32位
					struct stu{
						char a:9;
						char b:7;
						char c:2;
					}temp;//编译出错，位段a不能大于其存储单元的大小
				5.如一个段要从另一个存储单元开始，可以定义：
					struct stu{
						unsigend char a:1;
						unsigned char b:2;
						unsigned char :0;
						unsigned char c:3;(另一个单元)
					}date;
					由于用了长度为0的位段，其作用是使下一个位段从下一个存储单元开始存放
					将a、b存储在一个存储单元中，c另存在下一个单元
				6.可以定义无意义位段
					如：
						unsigned a:1;
						unsigned :2;
						unsigned b:3;
					位段的应用
						struct data{
							char a:1;
							char b:1;
							char c:1;
							char d:1;
							char e:1;
							char f:1;
							char g:1;
							char h:1;
						}temp;
						int main()
						{
							char p0;
							//p0=0x01;//0000 0001
							temp.a=1;
							//p0=temp;//错误，类型不匹配
							//p0=(char)temp;//错的，编译器不允许将结构体变量，强制转成基本类型的
							p0=*((char *)(&temp));

							return 0;
						}

	例子：
		若有一款芯片共有144个位(144bit),其中第98位表示xxx使能置1
		char config[18];
		int i=98;					//需要的位数
		int n;
		n=i/8;						//先算出在第几个字节（1byte==8bit）
		config[n] |= 1<<(i%8);		//先算出第几位，再通过左移位运算移到相应的位，最后通过与运算找到对应的位并置1，不会破坏原来的值
		//若置0		config[n] &= !(1<<(i%8));
		规定变量的位数（bit）
		例：
			struct stu{
				char a:1;
				char b:2;
				char c:7;
			};
			int main()
			{
				struct stu lucy={1,5,100};
				printf("%d  %d  %d",lucy.a,lucy.b,lucy.c);

				return 0;
			}//结果：  -1 1 -28
			lucy.c		只有7个位，100的二进制是1100100，最高位为1，不做为有效数据，所以识别成了负数，去掉补码和反码后二进制为0011100，转换为十进制是28，所以会出现-28的情况

			7位最大63最小-63
		若是利用这种办法去改变对应的位就很简单
			typedef unsigned char uchar;//定义无符号整型
			struct stu{
				uchar a:1;
				uchar b:2;
				uchar c:3;
				uchar d:1;//由于无符号整型没有负数，所以不存在最高位不是有效数据
			};
			int main()
			{
				struct stu lucy;
				lucy.d=1;
				printf("%d\n",lucy.d);//结果是1，用这种办法能够很有效的解决对位的操作，提高程序的阅读性 】

				return 0;
			}


共用体
	1.共用体和结构体类似，也是一种构造类型的数据结构。
		既然是构造类型的，也要先定义出类型，然后用类型定义变量。
		定义共用体类型的方法和结构体非常相似，把struct改成union就可以了。
		在进行某些算法的时候，需要使几种不同类型的变量存到同一段内存单元中，几个变量用   相互重叠
		这种几个不同的变量共同占用一段内存的结构，在c语言中，被称作”共用体“类型结构，
		共用体成员占有同一段地址空间
		共用体的大小是其占内存长度最大的成员的大小
		例：
			typedef struct data{
				short int i;
				char ch;
				float f;
			}DATA;
			DATA temp1;
			结构体变量temp1最小占7个字节(不考虑字节对齐)

			typedef union data{
				short int i;
				char ch;
				float f;
			}DATA;
			DATA temp2;
			共用体temp2占4个字节，即i、ch、f共用4个字节			
		
		共用体的特点：
			1.同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用
			2.共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员被覆盖
			3.共用体变量的地址和它各个成员的地址都是同一地址
			4.共用体变量的初始化
				unsigned data a={123};//初始化共用体第一个成员
			例： 
				typedef union data{
				unsigned char a;
				unsigned int b;
				}DATA;

				int main()
				{
					DATA temp;
					temp.b=0xffffffff;
					printf("temp.b=0x%x\n",temp.b);//结果是0xffffffff
					temp.a=0x3d;
					printf("temp.a=0x%x\n",temp.a);//结果是0x3d
					printf("temp.b=0x%x\n",temp.b);//结果是0xffffff3d

					return 0;
				}
		
		扩展：
			struct type{
				char a:1;
				char b:1;
				char c:1;
				char d:1;
				char e:1;
				char f:1;
				char g:1;
				char h:1;
			};
			union data{
				struct type temp;
				char p0;
			}m;
			int main()
			{
				m.temp.a=1;

				return 0;
			}


枚举
	将变量的值一一列举出来，变量的值只限于列举出来的值的范围内
	枚举类型也是结构类型的
	既然是结构类型的数据类型，就得先定义类型，再定义变量
	1.枚举类型的定义方法
		enum 枚举类型名{
			枚举值列表;
		};
		在枚举值表中应列出所有可用值，也称为枚举元素
		枚举变量仅能取枚举值所列元素
	
	2.枚举变量的定义方法
		enum 枚举类型名 枚举变量名;
		例：
			定义枚举类型变量week
			enum week//枚举类型
			{ 
				mon,tue,wed,thu,fri,sat,sun
			};
			enum week workday,weekday;//枚举变量
			workday与weekday只能取sun'''.sat中的一个

			workday = mon;//正确
			weekday = tue;//正确
			workday = abc;//错误，枚举值中没有abc
	
	枚举值是常量，不能在程序中用赋值语句再对它赋值
	例如：
		sun=5;mon=2;sun=mon;都是错误的
	
	枚举元素本身由系统定义了一个表示序号的数值，默认是从0开始顺序定义为0，1，2...
	在week中，mon的值为0，tue的值为1,...,sun的值为6

	可以改变枚举值的默认值：如
		enum week//枚举类型
		{
			mon=3.tue,wed,thu,fri=4,sat,sun
		};
		mon=3  tue=4,以此类推
		fri=4 以此类推
	注意：在定义枚举类型的时候枚举元素可以用等号给它赋值，用来代表在程序中，不能再次对枚举元素赋值，因为枚举元素是常量。


———————————————————————————————————————————————————————————————————————————————————链表————————————————————————————————————————————————————————————————————————————————————————————————————————————	

数组的特点：
	元素类型相同，连续存储，静态分配
	例：
		int len = 10;
		int arr[lem];//错误的，数组在程序编译的时候就已经静态分配好地址了，不可以改变数组的长度


变长数组：
	概念：
		变长数组既数组大小待定的数组， C语言中结构体的最后一个元素可以是大小未知的数组，也就是所谓的
		0长度，所以我们可以用结构体来创建变长数组。
	用途：
		它的主要用途是为了满足需要变长度的结构体，为了解决使用数组时内存的冗余和数组的越界问题。
	用法：
		在一个结构体的最后 ，申明一个长度为空的数组，就可以使得这个结构体是可变长的。对于编译器来说，
		此时长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量， 数组名这个符号本身
		代表了一个不可修改的地址常量 （注意：数组名永远都不会是指针！ ），但对于这个数组的大小，我们
		可以进行动态分配,对于编译器而言，数组名仅仅是一个符号，它不会占用任何空间，它在结构体中，只是
		代表了一个偏移量，代表一个不可修改的地址常量！
	例子：
		#include <stdio.h>
		#include <stdlib.h>//用到malloc函数

		struct fun{
			char num[0];//定义一个0长度的数组
		};

		int main()
		{
			struct fun *p=NULL;//定义一个fun结构体类型的p指针
			int i=0,len=0;

			printf("请输入您需要的字符串长度，系统会自动为您开辟出合适的空间：");//自定义数组长度
			scanf("%d",&len);

			p=malloc(sizeof(struct fun)+len);//开辟出一个fun型结构体大小加上所需数组长度的空间，并把开辟出来的空间地址赋值给结构体p

			for(;i<len;i++)
			{
				p->num[i]=i;//把p指向的num地址向后偏移几位就指向了对应的地址
				printf("p->num[%d]=%d\n",i,p->num[i]);
			}

			return 0;
		}
	缺点：
		malloc申请的空间，不能实现局部申请、释放


链表的概念
	链表是一种物理存储上非连续，数据元素的逻辑顺序通过链表中的指针链接次序实现的，
	链表由一系列节点（链表中每一个元素称为节点）组成，节点在运动时动态生成(mallo)，
	每个节点包括两个部分：
		1.存储数据元素的数据域
		2.存储下一个节点地址的指针域
	相比于线性表顺序结构，链表比较方便插入和删除操作


链表的构成：
	链表由一个个节点构成，每个节点一般采用结构体的形式组织，例如：
		typedef struct student
		{
			int num;
			char name[20];
			struct student *next;
		}STU;
	链表节点分为两个域
		数据域：存放各种实际的数据，如：num、score等
		指针域：存放下一个节点的首地址，如：next等
	

	head ---->    A   |-->   B   |-->   ...  |-->   N
				next--|	   next--|      ...--|     next


链表的创建以及插入
	步骤:
		1.创建链表类型
		2.使用malloc函数在堆区申请空间，类型为创建的链表类型，作为一个节点
		3.如果是第一次申请，需要保存这个节点的地址
		4.第二次及以后申请空间后，将最后申请的节点的指针域指向链接的地址，此节点的地址作为头部使用，以此类推
	例子:
		#include <stdio.h>
		#include <stdlib.h>
		
		typedef struct stu{					//链表类型
			char name[16]					//数据域，存储名字
			int age;						//数据域，存储年龄
			struct stu *next;				//指针域，存储下一个节点的地址
		}STU;
		
		STU *link_insert(STU *head,STU *pnew)	//STU类型的指针结构体函数 链接_插入(被插入的链接，要插入的节点)
		{
			if(head == NULL)				//如果是第一次创建
			{
				head = pnew;				//把这个节点的地址作为头
				pnew -> next = NULL;		//此节点的指针域指向空，因为后面暂时没有节点
			}
			else if(head != NULL)			//如果不是第一次创建
			{
				pnew -> next = head;		//将自己申请的节点指针域指向链接
				head = pnew;				//把这个节点作为头部使用
			}
			return head;					//返回头部地址
		}
		
		int main()
		{
			STU *head = NULL,*pnew=NULL;
			int i;
			for(i=0;i<3;i++)				//循环3次，申请3个节点
			{
				pnew = malloc(sizeof(STU));		//申请空间，作为节点使用
				head = link_insert(head,pnew);	//把申请的节点插入链接
			}
		}
	

链表的遍历
	步骤:
		1.先判断传入的指针是否为空指针，为真执行，检查到指向的为空时跳出
		2.打印后指向下一个节点，以此类推
	例子:
		void link_print(STU *data)			//无返回值类型  链接_打印(STU类型的链接地址)
		{
			while(head != NULL)				//检查传入的是否为空
			{
				printf("%s %d",data->name,data->age);		//打印数据域的名字和年龄
				data = data->next;			//指向下一个节点
			}
		}
		

链表的释放
	步骤:
		1.先判断传入的指针是否为空指针，为真执行，检查到指向的为空时跳出
		2.使用一个指针变量先记录第二个节点
		3.利用free函数释放第一个节点
		4.把第二个节点的地址作为头部，以此类推
	代码:
		STU *link_free(STU *head)			//STU类型的指针结构体函数 链接_释放(要释放的链接)
		{
			STU *temp;						//临时指针
			while(head != NULL)				//判断是否指向空
			{
				temp = head -> next;		//记录第二个节点的地址
				free(head);					//释放第一个节点
				head = temp;				//把第二个节点作为头部使用
			}
		}
	

链表节点的查找
	步骤:
		1.先判断传入的指针是否为空指针，为真执行，检查到指向的为空时跳出
		2.判断指向的节点的数据域是否有与自己需要的数据相匹配，相匹配就直接跳出，返回此节点的地址
		3.若不匹配则指向下一个节点，以此类推
	代码:
		STU *link_find(STU *head,char *name)	//STU类型的指针结构体函数 链接_查找(要查找的链接，要查找的数据)
		{
			while(head != NULL)				//判断传入的指针是否为空指针，为真执行，检查到指向的为空时跳出
			{
				if(strcmp(head->name,name)==0)break;	//因为查找的数据为字符串类型，所以使用strcmp字符匹配函数进行数据匹配，若匹配则跳出
				head = head ->next;			//若不匹配则会指向下一个节点
			}
			return head;					//返回匹配到的节点的地址
		}


链表节点的删除
	说明：
		先用数据查找到该节点，然后用free释放函数释放掉该节点
	步骤:
		1.先判断传入的指针是否为空指针，为真执行，检查到指向的为空时跳出
		2.判断指向的节点的数据域是否有与自己需要删除的节点的数据相匹配，如果相匹配
			1.判断该节点是否是头部，如果为头部则释放掉，并把第二个节点作为头部，
			2.如果不是头部，则把找到的节点释放掉，并且把找的节点的上一个节点的指针域指向找到的节点的下一个节点
			3.跳出循环，不再进行查找
		3.如果不匹配就继续查找，以此类推
	代码:
		STU *link_delete(STU *head,char *name)   	    //STU类型的指针结构体函数 链表_删除(被删除的节点所在的链表，被删除的节点所存储的数据)
		{
			STU *ps=head,*pf=head;						//*ps为正在查找的节点的上一个节点，*pf为正在查找的节点
			while(pf != NULL)							//判断传入的指针是否为空指针，为真执行，检查到指向的为空时跳出
			{
				if(strcmp(pf->name,name) == 0)			//判断指向的节点的数据域是否有与自己需要删除的节点的数据相匹配
				{
					if(pf == head) head=head->next;		//如果该节点为头部，把第二个节点作为头部，
					else ps->next=pf->next;				//否则 将正在查找的节点的上一个节点的指针域指向正在查找的节点的下一个节点
					free(pf);							//释放掉正在查找的节点
					break;								//跳出
				}
				ps = pf;								//记录刚才查找的节点
				pf = pf->next;							//指向下一个节点，开始新一轮的查找
			}
			return head;								//返回链接的头部
		}
		

链表节点的正反排序
	说明：
		先确定什么样的数据类型，如果是字符型，可以用stricmp函数确认大小，如果是非字符型可以用if判断比较大小，然后使用冒泡排序，这里不再记录，只给出函数原型
	代码:
		STU *link_sons(STU *head)          //根据姓名从小到大排序
		{
			STU *pf=head,*pb;
			while(pf->next != NULL)
			{
				pb=pf->next;
				while(pb != NULL)
				{
					if((*(pf->name) > *(pb->name))||((*(pf->name) == *(pb->name))&&(pf->num > pb->num)))
					{
						link_sorting(pf,pb);
					}
					pb = pb->next;
				}
				pf = pf->next;
			}
			return head;
		}

		STU *link_sond(STU *head)          //根据姓名从大到小排序
		{
			STU *pf=head,*pb;
			while(pf->next != NULL)
			{
				pb=pf->next;
				while(pb != NULL)
				{
					if((*(pf->name) < *(pb->name))||((*(pf->name) == *(pb->name))&&(pf->num < pb->num)))
					{
						link_sorting(pf,pb);
					}
					pb = pb->next;
				}
				pf = pf->next;
			}
			return head;
		}

		STU *link_sois(STU *head)          //根据学号从小到大排序
		{
			STU *pf=head,*pb;
			while(pf->next != NULL)
			{
				pb=pf->next;
				while(pb != NULL)
				{
					if((pf->num > pb->num)||((pf->num == pb->num)&&(*(pf->name) > *(pb->name))))
					{
						link_sorting(pf,pb);
					}
					pb = pb->next;
				}
				pf = pf->next;
			}
			return head;
		}

		STU *link_soid(STU *head)          //根据学号从大到小排序
		{
			STU *pf=head,*pb=NULL;
			while(pf->next != NULL)
			{
				pb=pf->next;
				while(pb != NULL)
				{
					if((pf->num < pb->num)||((pf->num == pb->num)&&(*(pf->name) < *(pb->name))))
					{
						link_sorting(pf,pb);
					}
					pb = pb->next;
				}
				pf = pf->next;
			}
			return head;
		}
		

双向链表的创建和遍历

双向链表节点的删除

双向链表插入节点




























